/* This file is automatically generated from multiple sources. Do not modify */


#ifndef MUXY_GAMELINK_SINGLE_HPP
#define MUXY_GAMELINK_SINGLE_HPP

#ifndef MUXY_GAMELINK_CONFIG_H
#define MUXY_GAMELINK_CONFIG_H

// Support custom string types.
#ifndef MUXY_GAMELINK_CUSTOM_STRING_TYPE
#include <string>
#define MUXY_GAMELINK_CUSTOM_STRING_TYPE std::string
#endif

#ifndef NO_JSON_INCLUDE
#include <nlohmann/json.hpp>
#endif

namespace gamelink
{
	/// This can be controlled by defining `MUXY_GAMELINK_CUSTOM_STRING_TYPE`.
	/// By default, MUXY_GAMELINK_CUSTOM_STRING_TYPE is std::string
	/// This string should
	///     * Provide a constructor from a null-terminated c-string of chars
	///     * Provide operator== with another instance of the string type.
	///     * Provide a c_str() that returns a pointer to the first element of a
	///       null-terminated array of utf8 encoded chars.
	typedef MUXY_GAMELINK_CUSTOM_STRING_TYPE string;
}

#endif



#ifndef MUXY_GAMELINK_SCHEMA_SERIALIZATION_H
#define MUXY_GAMELINK_SCHEMA_SERIALIZATION_H

#define MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, name, out, property)                                                                        \
	{                                                                                                                                      \
		nlohmann::json::const_iterator it = in.find(name);                                                                                 \
		if (it != in.end())                                                                                                                \
		{                                                                                                                                  \
			it->get_to(out.property);                                                                                                      \
		}                                                                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_0(Type)                                                                                                    \
	inline void to_json(nlohmann::json& out, const Type& p) {}                                                                             \
	inline void from_json(const nlohmann::json& in, Type& p) {}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_0(Type)                                                                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p) {}                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p) {}

#define MUXY_GAMELINK_SERIALIZE_1(Type, n1, p1)                                                                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(Type, n1, p1)                                                                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_2(Type, n1, p1, n2, p2)                                                                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(Type, n1, p1, n2, p2)                                                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_3(Type, n1, p1, n2, p2, n3, p3)                                                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(Type, n1, p1, n2, p2, n3, p3)                                                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_4(Type, n1, p1, n2, p2, n3, p3, n4, p4)                                                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_4(Type, n1, p1, n2, p2, n3, p3, n4, p4)                                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_5(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5)                                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_5(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5)                                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_6(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6)                                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_6(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6)                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_7(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7)                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_7(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7)                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_8(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8)                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_8(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8)                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_9(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9)                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_9(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9)                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_10(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9, n10, p10)                 \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
		out[n10] = p.p10;                                                                                                                  \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n10, p, p10)                                                                                \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_10(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9, n10, p10)       \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
		out[n10] = p.p10;                                                                                                                  \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n10, p, p10)                                                                                \
	}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_ENVELOPE_H
#define MUXY_GAMELINK_SCHEMA_ENVELOPE_H



namespace gamelink
{
	namespace schema
	{
		// A JSON atom reprsents one of the 4 supported base types of json value -
		// An integer, double, string, null
		enum JsonAtomType
		{
			JSON_ATOM_NULL,    //!< No fields are valid, the JSONAtom represents a null
			JSON_ATOM_INT64,   //!< The int64Value field is valid, and the JSONAtom represents an integer.
			JSON_ATOM_DOUBLE,  //!< The doubleValue field is valid, and the JSONAtom represents a double.
			JSON_ATOM_STRING,  //!< The stringValue field is valid, and the JSONAtom represents a string.
			JSON_ATOM_LITERAL, //!< The stringValue field is valid, and is a JSON encoded object or array.

			JSON_ATOM_FORCE_32 = 0xFFFFFFFF
		};

		/// JSONAtom is effectively a tagged union that can contain a signed 64-bit integer,
		/// a floating point double, a string, a json literal, or null. The type of a JSONAtom is stored in
		/// the `field` type.
		struct JsonAtom
		{
			/// Type of the contained value
			JsonAtomType type;

			/// Integer value
			int64_t int64Value;

			/// Double value
			double doubleValue;

			/// String value
			string stringValue;
		};

		/// Creates a JsonAtom that represents an integer
		/// @param[in] v Integer value
		/// @return JsonAtom that contains the input integer value
		JsonAtom atomFromInteger(int64_t v);

		/// Creates a JsonAtom that represents a double
		/// @param[in] d Double value
		/// @return JsonAtom that contains the input double value
		JsonAtom atomFromDouble(double d);

		/// Creates a JsonAtom that represents a string
		/// @param[in] str String value
		/// @return JsonAtom that contains the input string value
		JsonAtom atomFromString(const string& str);

		/// Creates a JsonAtom that represents an object
		/// @param[in] str JSON Literal
		/// @return JsonAtom that contains the input literal
		JsonAtom atomFromLiteral(const string& str);

		/// Creates a JsonAtom that represents null
		/// @return A null JsonAtom
		JsonAtom atomNull();

		void to_json(nlohmann::json& out, const JsonAtom& p);
		void from_json(const nlohmann::json& in, JsonAtom& p);

		/// Contains metadata fields about a response
		struct ReceiveMeta
		{
			ReceiveMeta();

			/// Request ID, as sent by the response
			uint16_t request_id;

			/// Action of the request
			string action;

			/// Target of the request
			string target;

			/// Unix timestamp in milliseconds since epoch.
			uint64_t timestamp;
		};

		MUXY_GAMELINK_SERIALIZE_4(ReceiveMeta, "request_id", request_id, "action", action, "target", target, "timestamp", timestamp)

		/// Error type, possibly returned by any API call.
		struct Error
		{
			/// Unsigned error code. Correlates to HTTP error codes.
			uint32_t number;

			/// Human readable error title.
			string title;

			/// Human readable detail field.
			string detail;
		};

		MUXY_GAMELINK_SERIALIZE_3(Error, "number", number, "title", title, "detail", detail)

		/// ReceiveEnvelope
		template<typename T>
		struct ReceiveEnvelope
		{
			/// Metadata about this response
			ReceiveMeta meta;

			/// Data field. Will vary based on the response.
			/// See the type documentation for more details.
			T data;

			/// Errors list. Mutually exclusive with data.
			/// May contain more than one error.
			std::vector<Error> errors;
		};

		template<typename T>
		void to_json(nlohmann::json& out, const ReceiveEnvelope<T>& p)
		{
			out["meta"] = p.meta;
			out["data"] = p.data;

			if (p.errors.size())
			{
				out["errors"] = p.errors;
			}
		}

		template<typename T>
		void from_json(const nlohmann::json& in, ReceiveEnvelope<T>& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "meta", p, meta);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "data", p, data);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "errors", p, errors);
		}

		struct SendParameters
		{
			SendParameters();

			/// Request ID. Will be echoed back in the response.
			/// By default, is 0xFFFF
			uint16_t request_id;

			/// Target field. Will vary in behavior based on action.
			string target;
		};

		inline void to_json(nlohmann::json& out, const SendParameters& p)
		{
			out["request_id"] = p.request_id;
			if (p.target.size())
			{
				out["target"] = p.target;
			}
		}

		inline void from_json(const nlohmann::json& in, SendParameters& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "request_id", p, request_id);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "target", p, target);
		}

		template<typename T>
		struct SendEnvelope
		{
			/// The action of this request.
			string action;

			/// Parameters of this request.
			SendParameters params;

			/// Data field. Will vary based on the response.
			/// See the type documentation for more details.
			T data;
		};

		template<typename T>
		void to_json(nlohmann::json& out, const SendEnvelope<T>& p)
		{
			out["action"] = p.action;
			out["params"] = p.params;
			out["data"] = p.data;
		}

		template<typename T>
		void from_json(const nlohmann::json& in, SendEnvelope<T>& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "action", p, action);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "params", p, params);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "data", p, data);
		}

		template<typename T>
		std::string to_string(const SendEnvelope<T>& p)
		{
			nlohmann::json out;
			to_json(out, p);
			return out.dump();
		}

		/// The empty body. Has no members.
		struct EmptyBody
		{
		};

		/// OKResponseBody is sent back when a simple operation succeeds.
		struct OKResponseBody
		{
			/// Will always be 'true'. If an error occurred, then
			/// the errors array in the response would be set.
			bool ok;
		};

		MUXY_GAMELINK_SERIALIZE_1(OKResponseBody, "ok", ok)

		// Specialization for empty body serialization
		MUXY_GAMELINK_SERIALIZE_2(SendEnvelope<EmptyBody>, "action", action, "params", params);
		MUXY_GAMELINK_SERIALIZE_2(ReceiveEnvelope<EmptyBody>, "meta", meta, "errors", errors);

		/// Parse a response object
		/// @param[in] bytes JSON input bytes. Must not be null.
		/// @param[in] length Length of the bytes parameter
		/// @param[out] out Output object. Should be a ResponseEnvelope or a type inherited from ResponseEnvelope.
		/// @return true iff the input JSON parsed correctly, false otherwise
		template<typename T>
		bool ParseResponse(const char* bytes, uint32_t length, T& out)
		{
			nlohmann::json value = nlohmann::json::parse(bytes, bytes + length, nullptr, false);
			if (value.is_discarded())
			{
				return false;
			}

			from_json(value, out);
			return true;
		}

		/// Parses a ReceiveEnvelope only. Does not attempt to parse the body.
		/// @param[in] bytes JSON input bytes. Must not be null.
		/// @param[in] length Length of the bytes parameter
		/// @param[out] success Optional boolean to determine parse failure. Will be set to true iff the parse succeeded, false otherwise.
		/// @return A ReceiveEnvelope with no body, only metadata field and possibly errors.
		ReceiveEnvelope<EmptyBody> ParseEnvelope(const char* bytes, uint32_t length, bool* success = nullptr);
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_SUBSCRIPTION_H
#define MUXY_GAMELINK_SCHEMA_SUBSCRIPTION_H

namespace gamelink
{
	namespace schema
	{
		struct SubscribeTopicRequestBody
		{
			string topic_id;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(SubscribeTopicRequestBody, "topic_id", topic_id);
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_PURCHASE_H
#define MUXY_GAMELINK_SCHEMA_PURCHASE_H


namespace gamelink
{
	namespace schema
	{
		template<typename T>
		struct TwitchPurchaseBitsResponseBody
		{
			string sku;
			string displayName;
			string userId;
			string username;

			T additional;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_5(TwitchPurchaseBitsResponseBody,
												"sku",
												sku,
												"displayName",
												displayName,
												"userId",
												userId,
												"username",
												username,
												"additional",
												additional);
		};

		template<typename T>
		struct TwitchPurchaseBitsResponse : ReceiveEnvelope<TwitchPurchaseBitsResponseBody<T>>
		{
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_AUTHENTICATION_H
#define MUXY_GAMELINK_SCHEMA_AUTHENTICATION_H


namespace gamelink
{
	namespace schema
	{
		struct AuthenticateWithPINRequestBody
		{
			/// PIN string, as obtained from the REST API
			string pin;

			/// Client ID, as obtained from Twitch.
			string client_id;
		};
		MUXY_GAMELINK_SERIALIZE_2(AuthenticateWithPINRequestBody, "pin", pin, "client_id", client_id);

		struct AuthenticateWithJWTRequestBody
		{
			/// JWT string, as obtained from previous authorizations
			string jwt;

			/// Client ID, as obtained from Twitch.
			string client_id;
		};
		MUXY_GAMELINK_SERIALIZE_2(AuthenticateWithJWTRequestBody, "jwt", jwt, "client_id", client_id);

		struct AuthenticateJWTResponseBody
		{
			/// Signed JWT. Will expire.
			string jwt;
		};
		MUXY_GAMELINK_SERIALIZE_1(AuthenticateJWTResponseBody, "jwt", jwt);

		struct SubscribeAuthenticationRequest : SendEnvelope<EmptyBody>
		{
			SubscribeAuthenticationRequest();
		};

		struct SubscribeAuthenticationResponse : ReceiveEnvelope<OKResponseBody>
		{
		};

		struct AuthenticateWithPINRequest : SendEnvelope<AuthenticateWithPINRequestBody>
		{
			/// Creates an authorization request.
			/// @param[in] clientID Client ID.
			/// @param[in] pin PIN obtained from user input.
			AuthenticateWithPINRequest(const string& clientID, const string& pin);
		};

		struct AuthenticateWithJWTRequest : SendEnvelope<AuthenticateWithJWTRequestBody>
		{
			/// Creates an authorization request
			/// @param[in] clientID Client ID.
			/// @param[in] jwt JWT obtained from previous authorizations.
			AuthenticateWithJWTRequest(const string& clientID, const string& jwt);
		};

		struct AuthenticateResponse : ReceiveEnvelope<AuthenticateJWTResponseBody>
		{
		};

		class User
		{
		public:
			explicit User(string jwt);

			const string& GetJWT() const;
			// string GetOpaqueID();
		private:
			string jwt;
		};
	}
}
#endif


#ifndef MUXY_GAMELINK_SCHEMA_POLL_H
#define MUXY_GAMELINK_SCHEMA_POLL_H



namespace gamelink
{
	namespace schema
	{
		struct GetPollRequestBody
		{
			/// The Poll ID to get
			string pollId;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(GetPollRequestBody, "poll_id", pollId);
		};

		struct DeletePollRequestBody
		{
			string pollId;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(DeletePollRequestBody, "poll_id", pollId);
		};

		struct CreatePollRequestBody
		{
			/// The Poll ID to create. Poll IDs are scoped to the current channel.
			string pollId;

			/// The poll prompt
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(CreatePollRequestBody, "poll_id", pollId, "prompt", prompt, "options", options);
		};

		template<typename T>
		struct CreatePollWithUserDataRequestBody
		{
			/// The Poll ID to create
			string pollId;

			/// The prompt for the poll.
			string prompt;

			/// An array of options for the poll
			std::vector<string> options;

			/// Arbitrary serializable user data.
			T userData;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_4(CreatePollWithUserDataRequestBody,
												"poll_id",
												pollId,
												"prompt",
												prompt,
												"options",
												options,
												"user_data",
												userData);
		};

		struct PollResponseBody
		{
			/// The Poll ID that the update is for
			string pollId;

			/// The prompt for the poll.
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollResponseBody, "poll_id", pollId, "prompt", prompt, "options", options);
		};

		template<typename T>
		struct PollWithUserDataResponseBody
		{
			/// The prompt for the poll.
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			/// Arbitrary user data type. Must be marked up with the MUXY_GAMELINK_SERIALIZE macro.
			T userData;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollWithUserDataResponseBody, "prompt", prompt, "options", options, "user_data", userData);
		};

		// Note that this is the same as PollUpdateBody, and is provided for consistency with each 
		// endpoint having their own envelope with body.
		struct GetPollResponseBody
		{
			/// The poll information
			PollResponseBody poll;

			/// Array of vote counts for each poll option. This array may not be the same size as the
			/// options array.
			std::vector<int> results;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(GetPollResponseBody, "poll", poll, "results", results);
		};

		struct PollUpdateBody
		{
			/// The poll information
			PollResponseBody poll;

			/// Array of vote counts for each poll option. This array may not be the same size as the
			/// options array.
			std::vector<int> results;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(PollUpdateBody, "poll", poll, "results", results);
		};

		template<typename T>
		struct PollWithUserDataUpdateBody
		{
			/// The Poll ID that this update represents
			string pollId;

			/// The poll prompt and options.
			PollWithUserDataResponseBody<T> poll;

			/// An array of vote counts for each poll option. This array may not be the same
			/// size as the options array.
			std::vector<int> results;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollWithUserDataUpdateBody, "topic_id", pollId, "poll", poll, "results", results);
		};

		struct GetPollRequest : SendEnvelope<GetPollRequestBody>
		{
			/// Creates a GetPoll request
			/// @param[in] pollId The ID of the poll to get. Maximum size 64 characters.
			explicit GetPollRequest(const string& pollId);
		};

		struct CreatePollRequest : SendEnvelope<CreatePollRequestBody>
		{
			/// Creates a CreatePoll request.
			/// @param[in] pollId The ID of the poll to create. This can overwrite existing polls if the same
			///                   id is specified.
			/// @param[in] prompt The prompt for the poll to create.
			/// @param[in] options vector of options for the poll.
			CreatePollRequest(const string& pollId, const string& prompt, const std::vector<string>& options);
		};

		template<typename T>
		struct CreatePollWithUserDataRequest : SendEnvelope<CreatePollWithUserDataRequestBody<T>>
		{
			/// Creates a CreatePoll request, but with user data.
			/// @param[in] pollId The ID of the poll to create. This can overwrite existing polls if the same
			///                   id is specified.
			/// @param[in] prompt The prompt for the poll to create.
			/// @param[in] options vector of options for the poll.
			/// @param[in] userData Arbitrary user data to attach to this poll. This type should be serializable. The fully marshalled
			///                     size of this type should be under 1kb.
			CreatePollWithUserDataRequest(const string& pollId, const string& prompt, const std::vector<string>& options, const T& userData)
			{
				this->action = string("create");
				this->params.target = string("poll");

				this->data.pollId = pollId;
				this->data.prompt = prompt;
				this->data.options = options;

				this->data.userData = userData;
			}
		};

		struct SubscribePollRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribePollRequest.
			/// @param[in] pollId The ID of the poll to subscribe to updates for.
			explicit SubscribePollRequest(const string& pollId);
		};

		struct PollUpdateResponse : ReceiveEnvelope<PollUpdateBody>
		{
		};

		struct GetPollResponse : ReceiveEnvelope<GetPollResponseBody>
		{
		};

		template<typename T>
		struct PollWithUserDataUpdateResponse : ReceiveEnvelope<PollWithUserDataUpdateBody<T>>
		{
		};

		struct DeletePollRequest : SendEnvelope<DeletePollRequestBody>
		{
			/// Creates a DeletePoll request
			/// @param[in] pollId 	The ID of the poll to be deleted.
			explicit DeletePollRequest(const string& pollId);
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_H
#define MUXY_GAMELINK_SCHEMA_H










#endif


#ifndef MUXY_GAMELINK_SCHEMA_STATE_H
#define MUXY_GAMELINK_SCHEMA_STATE_H



namespace gamelink
{
	namespace schema
	{
		// Set / Get state
		template<typename T>
		struct SetStateRequestBody
		{
			/// Either 'channel' or 'extension', based on the target.
			string state_id;

			/// The state to set. The type `T` should be serializable
			/// through use of the MUXY_GAMELINK_SERIALIZE macros.
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(SetStateRequestBody, "state_id", state_id, "state", state);
		};

		template<typename T>
		struct StateResponseBody
		{
			/// Will always be true.
			bool ok;

			/// State response. The type `T` should be serializable
			/// through use of the MUXY_GAMELINK_SERIALIZE macros.
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(StateResponseBody, "ok", ok, "state", state);
		};

		/// Channel State target
		static const char* STATE_TARGET_CHANNEL = "channel";

		/// Extension State target
		static const char* STATE_TARGET_EXTENSION = "extension";

		template<typename T>
		struct SetStateRequest : SendEnvelope<SetStateRequestBody<T>>
		{
			/// Creates a SetState request.
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			/// @param[in] value A serializable type.
			SetStateRequest(const char* target, const T& value)
			{
				this->action = string("set");
				this->params.target = string("state");
				this->data.state_id = string(target);
				this->data.state = value;
			}
		};

		template<typename T>
		struct SetStateResponse : ReceiveEnvelope<StateResponseBody<T>>
		{
		};

		struct GetStateRequestBody
		{
			/// Either 'channel' or 'extension', based on the target.
			string state_id;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(GetStateRequestBody, "state_id", state_id);
		};

		struct GetStateRequest : SendEnvelope<GetStateRequestBody>
		{
			/// Creates a GetState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit GetStateRequest(const char* target);
		};

		template<typename T>
		struct GetStateResponse : ReceiveEnvelope<StateResponseBody<T>>
		{
		};

		// Update state
		struct PatchOperation
		{
			string operation;
			string path;
			JsonAtom value;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PatchOperation, "op", operation, "path", path, "value", value);
		};

		struct PatchStateRequestBody
		{
			/// Either 'channel' or 'extension', based on the target.
			string state_id;

			std::vector<PatchOperation> state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(PatchStateRequestBody, "state_id", state_id, "state", state);
		};

		struct PatchStateRequest : SendEnvelope<PatchStateRequestBody>
		{
			/// Creates an UpdateState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit PatchStateRequest(const char* target);
		};

		// Subscription
		template<typename T>
		struct StateUpdateBody
		{
			string topic_id;
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(StateUpdateBody, "topic_id", topic_id, "state", state);
		};

		struct SubscribeStateRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribeState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit SubscribeStateRequest(const char* target);
		};

		template<typename T>
		struct SubscribeStateUpdateResponse : ReceiveEnvelope<StateUpdateBody<T>>
		{
		};
	}
}
#endif


#ifndef MUXY_GAMELINK_SCHEMA_BROADCAST_H
#define MUXY_GAMELINK_SCHEMA_BROADCAST_H


namespace gamelink
{
    namespace schema
    {
        struct BroadcastRequestBody
        {
            string message;
            string topic;

            MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(BroadcastRequestBody, "message", message, "topic", topic);
        };

        struct BroadcastRequest : SendEnvelope<BroadcastRequestBody>
        {
            BroadcastRequest(const string& topic, const string& msg);
        };

        struct BroadcastResponse : ReceiveEnvelope<OKResponseBody>
        {};
    }
}

#endif

#ifndef MUXY_GAMELINK_SCHEMA_DATASTREAM_H
#define MUXY_GAMELINK_SCHEMA_DATASTREAM_H



namespace gamelink
{
	namespace schema
	{
		struct DatastreamEvent
		{
			nlohmann::json event;
			int64_t timestamp;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(DatastreamEvent, "event", event, "timestamp", timestamp);
		};

		struct DatastreamUpdateBody
		{
			std::vector<DatastreamEvent> events;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(DatastreamUpdateBody, "events", events);
		};

		struct DatastreamUpdate : ReceiveEnvelope<DatastreamUpdateBody>
		{
		};

		struct SubscribeDatastreamRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribeDatastreamRequest
			explicit SubscribeDatastreamRequest();
		};

	}
}

#endif


#ifndef INCLUDE_MUXY_GAMELINK_H
#define INCLUDE_MUXY_GAMELINK_H


#include <queue>

namespace gamelink
{
	class Payload
	{
	public:
		explicit Payload(string data);

		string data;
	};

	namespace detail
	{
		static const uint32_t CALLBACK_PERSISTENT = 0;
		static const uint32_t CALLBACK_ONESHOT = 1;
		static const uint32_t CALLBACK_ONESHOT_CONSUMED = 2;

		template<typename T>
		class Callback
		{
		public:
			typedef void (*RawFunctionPointer)(void*, const T&);

			Callback(uint32_t id, uint16_t targetRequestId, uint32_t oneShotStatus)
				: id(id)
				, targetRequestId(targetRequestId)
				, oneShotStatus(oneShotStatus)
				, _rawCallback(nullptr)
				, _user(nullptr)
			{
			}

			void invoke(const T& v)
			{
				if (_rawCallback)
				{
					_rawCallback(_user, v);
				}
				else if (_callback)
				{
					_callback(v);
				}

				if (oneShotStatus == CALLBACK_ONESHOT)
				{
					oneShotStatus = CALLBACK_ONESHOT_CONSUMED;
				}
			}

			void set(std::function<void(const T&)> fn)
			{
				_rawCallback = nullptr;
				_user = nullptr;

				_callback = fn;
			}

			void set(RawFunctionPointer cb, void* user)
			{
				_rawCallback = cb;
				_user = user;

				_callback = std::function<void(const T&)>();
			}

			void clear()
			{
				_rawCallback = nullptr;
				_user = nullptr;

				_callback = std::function<void(const T&)>();
			}

			bool valid() const
			{
				if (_rawCallback)
				{
					return true;
				}

				if (_callback)
				{
					return true;
				}

				return false;
			}

			uint32_t id;
			uint16_t targetRequestId;
			uint32_t oneShotStatus;

		private:
			RawFunctionPointer _rawCallback;
			void* _user;

			std::function<void(const T&)> _callback;
		};

		static const uint16_t ANY_REQUEST_ID = 0xFFFF;

		template<typename T, uint8_t IDMask>
		class CallbackCollection
		{
		public:
			CallbackCollection()
				: currentHandle(0)
			{
			}

			typedef void (*RawFunctionPointer)(void*, const T&);

			bool validateId(uint32_t id)
			{
				// Check the ID byte for consistency.
				return ((id >> 24) & 0xFF) == IDMask;
			}

			uint32_t set(std::function<void(const T&)> fn, uint16_t requestId, uint32_t flags)
			{
				uint32_t id = nextID();
				Callback<T> cb(id, requestId, flags);
				cb.set(fn);

				callbacks.emplace_back(std::move(cb));

				return id;
			}

			uint32_t set(RawFunctionPointer fn, void* user, uint16_t requestId, uint32_t flags)
			{
				uint32_t id = nextID();
				Callback<T> cb(id, requestId, flags);
				cb.set(fn, user);

				callbacks.emplace_back(std::move(cb));

				return id;
			}

			void remove(uint32_t id)
			{
				callbacks.erase(std::remove_if(callbacks.begin(), callbacks.end(), [id](const Callback<T>& cb) { return cb.id == id; }),
								callbacks.end());
			}

			void invoke(const T& v)
			{
				uint16_t requestId = v.meta.request_id;
				for (uint32_t i = 0; i < callbacks.size(); ++i)
				{
					if (callbacks[i].targetRequestId == ANY_REQUEST_ID || callbacks[i].targetRequestId == requestId)
					{
						callbacks[i].invoke(v);
					}
				}

				callbacks.erase(std::remove_if(callbacks.begin(), callbacks.end(),
											   [](const Callback<T>& cb) { return cb.oneShotStatus == CALLBACK_ONESHOT_CONSUMED; }),
								callbacks.end());
			}

		private:
			uint32_t nextID()
			{
				// Store a byte to determine if the id returned from a set operation belongs to this
				// collection of callbacks.
				static const uint32_t MASK = 0x0FFFFFFFu;
				uint32_t id = (currentHandle & (MASK)) | (static_cast<uint32_t>(IDMask) << 24);
				currentHandle = (currentHandle + 1) & 0x0FFFFFFFu;
				return id;
			}

			uint32_t currentHandle;
			std::vector<Callback<T>> callbacks;
		};
	}

	/// Not thread safe.
	class SDK
	{
	public:
		SDK();
		~SDK();

		// Not implemented. SDK is not copyable
		SDK(const SDK&);
		SDK& operator=(const SDK&);

		// Not implemented. SDK is not movable
		SDK(SDK&&);
		SDK& operator=(SDK&&);

		/// Receives a character buffer as a message. This function
		/// may invoke callbacks.
		///
		/// @param[in] bytes Pointer to contiguous array of bytes that represent a network message.
		/// @param[in] length Length of the bytes array.
		/// @return Returns true if the message was parsed correctly.
		bool ReceiveMessage(const char* bytes, uint32_t length);

		/// Returns true if there are a non-zero amount of payloads to send.
		///
		/// @return returns if there are payloads to send.
		bool HasPayloads() const;

		/// Invokes a callable type for each avaliable payload.
		///
		/// @param[in] networkCallback callback invoked once for each available payload.
		///                            must be in the form networkCallback(const Payload*)
		template<typename T>
		void ForeachPayload(const T& networkCallback)
		{
			while (HasPayloads())
			{
				Payload* payload = _queuedPayloads.front();
				_queuedPayloads.pop();

				networkCallback(payload);

				// Clean up send
				delete payload;
			}
		}

		typedef void (*NetworkCallback)(void*, const Payload*);

		/// Invokes a function pointer for each avaliable payload.
		///
		/// @param[in] cb Callback to be invoked for each avaliable payload
		/// @param[in] user User pointer that is passed into the callback
		void ForeachPayload(NetworkCallback cb, void* user);

		/// Returns if an authentication message has been received.
		///
		/// @return true if an authentication message has been received.
		bool IsAuthenticated() const;

		/// Gets the currently authenticated user.
		///
		/// @return The currently authenticated user, or null if no authentication message
		///         has been recieved.
		const schema::User* GetUser() const;

		/// Sets the OnDebugMessage callback. This is invoked for debugging purposes only.
		/// There can only be one OnDebugMessage callback registered.
		///
		/// @param[in] callback Callback to log a debug message
		void OnDebugMessage(std::function<void(const string&)> callback);

		/// Sets the OnDebugMessage callback with a function pointer and user pointer.
		/// This is invoked for debugging purposes only.
		/// There can only be one OnDebugMessage callback registered.
		///
		/// @param[in] callback Callback to log a debug message.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		void OnDebugMessage(void (*callback)(void*, const string&), void* ptr);

		/// Detaches the OnDebugMessage callback, so no additional calls will be made.
		void DetachOnDebugMessage();

		/// Sets the OnPollUpdate callback. This callback is invoked after SubscribeToPoll is called.
		/// @remark SubscribeToPoll takes in a poll id, but can be called multiple times with different poll ids.
		///        Callbacks registered through OnPollUpdate receive all update messages, regardless of poll id.
		///        Callbacks that are designed to only get updates for a specific poll id should test the poll id
		///        from within the callback itself.
		///
		/// @param[in] callback Callback to invoke when a poll update message is received
		/// @return Returns an integer handle to the callback, to be used in DetachOnPollUpdate.
		uint32_t OnPollUpdate(std::function<void(const schema::PollUpdateResponse&)> callback);

		/// Sets the OnPollUpdate callback. This callback is invoked after SubscribeToPoll is called.
		/// See the std::function overload for remarks.
		///
		/// @param[in] callback Callback to invoke when a poll update message is received
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnPollUpdate.
		uint32_t OnPollUpdate(void (*callback)(void*, const schema::PollUpdateResponse&), void* ptr);

		/// Detaches an OnPollUpdate callback.
		///
		/// @param[in] id A handle obtained from calling OnPollUpdate. Invalid handles are ignored.
		void DetachOnPollUpdate(uint32_t id);

		/// Sets the OnAuthenticate callback. This callback is invoked when an authentication
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when an authentication message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnAuthenticate.
		uint32_t OnAuthenticate(std::function<void(const schema::AuthenticateResponse&)> callback);

		/// Sets the OnAuthenticate callback. This callback is invoked when an authentication
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when an authentication message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnAuthenticate.
		uint32_t OnAuthenticate(void (*callback)(void*, const schema::AuthenticateResponse&), void* ptr);

		/// Detaches an OnAuthenticate callback.
		///
		/// @param[in] id A handle obtained from calling OnAuthenticate. Invalid handles are ignored.
		void DetachOnAuthenticate(uint32_t id);

		/// Sets the OnStateUpdate callback. This callback is invoked when a state update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a state update message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnStateUpdate.
		uint32_t OnStateUpdate(std::function<void(const schema::SubscribeStateUpdateResponse<nlohmann::json>&)> callback);

		/// Sets the OnStateUpdate callback. This callback is invoked when a state update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a state update message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnStateUpdate.
		uint32_t OnStateUpdate(void (*callback)(void*, const schema::SubscribeStateUpdateResponse<nlohmann::json>&), void* ptr);

		/// Detaches an OnStateUpdate callback.
		///
		/// @param[in] id A handle obtained from calling OnStateUpdate. Invalid handles are ignored.
		void DetachOnStateUpdate(uint32_t id);

		/// Sets the OnTwitchPurchaseBits callback. This callback is invoked when twitch purchase
		/// message is received.
		/// @remarks The twitch purchase message has been authenticated and deduplicated by the server.
		///          This callback receives all SKUs purchased, so a callback for a specific SKU should
		///          test the SKU in the callback.
		///
		/// @param[in] callback Callback to invoke when a twitch purchase message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnTwitchPurchaseBits.
		uint32_t OnTwitchPurchaseBits(std::function<void(const schema::TwitchPurchaseBitsResponse<nlohmann::json>&)> callback);

		/// Sets the OnTwitchPurchaseBits callback. This callback is invoked when twitch purchase
		/// message is received.
		/// See the std::function overload for remarks.
		///
		/// @param[in] callback Callback to invoke when a twitch purchase message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnTwitchPurchaseBits.
		uint32_t OnTwitchPurchaseBits(void (*callback)(void*, const schema::TwitchPurchaseBitsResponse<nlohmann::json>&), void* ptr);

		/// Detaches an OnTwitchPurchaseBits callback.
		///
		/// @param[in] id A handle obtained from calling OnTwitchPurchaseBits. Invalid handles are ignored.
		void DetachOnTwitchPurchaseBits(uint32_t id);

		/// Queues an authentication request using a PIN code, as received by the user from an
		/// extension's config view.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] pin 		The PIN input from the broadcaster
		void AuthenticateWithPIN(const string& clientId, const string& pin);

		/// Queues an authentication request using a PIN code, as received by the user from an
		/// extension's config view.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] pin 		The PIN input from the broadcaster
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		void
		AuthenticateWithPIN(const string& clientId, const string& pin, std::function<void(const schema::AuthenticateResponse&)> callback);

		/// Queues an authentication request using a PIN code, as received by the user from an
		/// extension's config view.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] pin 		The PIN input from the broadcaster
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		void AuthenticateWithPIN(const string& clientId,
								 const string& pin,
								 void (*callback)(void*, const schema::AuthenticateResponse&),
								 void* user);

		/// Queues an authentication request using a JWT, as received after a successful PIN authentication request.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] jwt 		The stored JWT from a previous authentication
		void AuthenticateWithJWT(const string& clientId, const string& jwt);

		/// Queues an authentication request using a JWT, as received after a successful PIN authentication request.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] jwt 		The stored JWT from a previous authentication
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		void
		AuthenticateWithJWT(const string& clientId, const string& pin, std::function<void(const schema::AuthenticateResponse&)> callback);

		/// Queues an authentication request using a JWT, as received after a successful PIN authentication request.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] jwt 		The stored JWT from a previous authentication
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		void AuthenticateWithJWT(const string& clientId,
								 const string& pin,
								 void (*callback)(void*, const schema::AuthenticateResponse&),
								 void* user);

		// Poll stuff, all async.

		/// Queues a request to get poll information, including results, for the poll with the given ID.
		/// Roughly equivilent to a single poll subscription update.
		/// Results are obtained through the OnPollUpdate callback.
		///
		/// @param[in] pollId The Poll ID to get information for
		void GetPoll(const string& pollId);

		/// Queues a request to get poll information. This overload attaches a one-shot callback to be
		/// called when poll information is received.
		///
		/// @param[in] pollId   The Poll ID to get information for
		/// @param[in] callback Callback invoked when this get poll request is responded to.
		void GetPoll(const string& pollId, std::function<void(const schema::GetPollResponse&)> callback);

		/// Queues a request to get poll information. This overload attaches a one-shot callback to be
		/// called when poll information is received.
		///
		/// @param[in] pollId   The Poll ID to get information for
		/// @param[in] callback Callback invoked when this get poll request is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		void GetPoll(const string& pollId, void (*callback)(void*, const schema::GetPollResponse&), void* user);

		/// Queues a request to create a poll.
		///
		/// @param[in] pollId The Poll ID to create
		/// @param[in] prompt The Prompt to store in the poll.
		/// @param[in] options An array of options to store in the poll.
		void CreatePoll(const string& pollId, const string& prompt, const std::vector<string>& options);

		/// Queues a request to create a poll.
		///
		/// @param[in] pollId The Poll ID to create
		/// @param[in] prompt The Prompt to store in the poll.
		/// @param[in] optionsBegin Pointer to the first element in an array of options to store in the poll.
		/// @param[in] optionsEnd Pointer one past the final entry in an array of options to store in the poll.
		void CreatePoll(const string& pollId, const string& prompt, const string* optionsBegin, const string* optionsEnd);

		/// Subscribes to updates for a given poll.
		/// Updates come through the OnPollUpdate callback.
		/// Once a poll stops receiving new votes, the subscription will stop receiving new updates.
		///
		/// @param[in] pollId The Poll ID to create
		void SubscribeToPoll(const string& pollId);

		/// Deletes the poll with the given ID.
		///
		/// @param[in] pollId 	The ID of the poll to delete.
		void DeletePoll(const string& pollId);

		// State operations, all async.

		/// Queues a request to replace the entirety of state with new information.
		/// This will generate a StateUpdate subscription event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] value A serializable type. Will overwrite any existing state for the given target.
		///                  Cannot be an array or primitive type.
		template<typename T>
		void SetState(const char* target, const T& value)
		{
			nlohmann::json js = nlohmann::json(value);
			SetState(target, js);
		};

		/// Queues a request to replace the entirety of state with new information.
		/// This will generate a StateUpdate subscription event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] value JSON. Will overwrite any existing state for the given target.
		///                  Must be an object, not an array or primitive type.
		void SetState(const char* target, const nlohmann::json& value);

		/// Queues a request to get state.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		void GetState(const char* target);

		/// Queues a request to get state. This overload attaches a one-shot callback to be
		/// called when state is received.
		///
		/// @param[in] target   Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] callback Callback invoked when this state request is responded to.
		void GetState(const char* target, std::function<void(const schema::GetStateResponse<nlohmann::json>&)> callback);

		/// Queues a request to get state. This overload attaches a one-shot callback to be
		/// called when state is received.
		///
		/// @param[in] target   Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] callback Callback invoked when this state request is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		void GetState(const char* target, void (*callback)(void*, const schema::GetStateResponse<nlohmann::json>&), void* user);

		/// Queues a request to do a single JSON Patch operation on the state object.
		/// This will generate a StateUpdate event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] operation A JSON Patch operation
		/// @param[in] path A JSON Patch path.
		/// @param[in] atom The value to use in the patch operation
		void UpdateState(const char* target, const string& operation, const string& path, const schema::JsonAtom& atom);

		/// Queues a request to do many JSON Patch operations on the state object.
		/// This will generate a StateUpdate event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] begin Pointer to the first element in an array of UpdateOperations
		/// @param[in] end Pointer one past the last element in an array of UpdateOperations
		void UpdateState(const char* target, const schema::PatchOperation* begin, const schema::PatchOperation* end);

		/// Starts subscribing to state updates for the given target.
		/// Updates come through the OnStateUpdate callback
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		void SubscribeToStateUpdates(const char* target);

		/// Sends a broadcast to all viewers on the channel using the extension.
		/// @remark The serialized size of the value parameter must be under 8 kilobytes.
		///
		/// @param[in] topic The topic of the message to send. The frontend uses this value
		///                  to filter messages.
		/// @param[in] value Serializable, arbitrary object.
		template<typename T>
		void SendBroadcast(const string& topic, const T& value)
		{
			nlohmann::json js = nlohmann::json(value);
			SendBroadcast(topic, js);
		}

		/// Sends a broadcast to all viewers on the channel using the extension.
		/// @remark The serialized size of the message parameter must be under 8 kilobytes.
		///
		/// @param[in] topic The topic of the message to send. The frontend uses this value
		///                  to filter messages.
		/// @param[in] message Arbitrary json object. May not be a primitive or array.
		void SendBroadcast(const string& topic, const nlohmann::json& message);

		/// Sends a request to subscribe to the datastream.
		void SubscribeToDatastream();

		/// Sets a OnDatastream callback. This callback is invoked when a datastream update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a datastream update message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnDatastream.
		uint32_t OnDatastream(std::function<void(const schema::DatastreamUpdate&)> callback);

		/// Sets a OnDatastream callback. This callback is invoked when a datastream update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a datastream update message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnDatastream.
		uint32_t OnDatastream(void (*callback)(void*, const schema::DatastreamUpdate&), void* user);

		/// Detaches an OnDatastream callback.
		///
		/// @param[in] id A handle obtained from calling OnDatastream. Invalid handles are ignored.
		void DetachOnDatastream(uint32_t);

	private:
		void debugLogPayload(const Payload*);

		template<typename T>
		void queuePayload(const T& p)
		{
			Payload* payload = new Payload(to_string(p));
			debugLogPayload(payload);
			_queuedPayloads.push(payload);
		}

		std::queue<Payload*> _queuedPayloads;
		schema::User* _user;

		uint16_t _currentRequestId;
		uint16_t nextRequestId();

		detail::Callback<string> _onDebugMessage;

		detail::CallbackCollection<schema::PollUpdateResponse, 1> _onPollUpdate;
		detail::CallbackCollection<schema::AuthenticateResponse, 2> _onAuthenticate;
		detail::CallbackCollection<schema::SubscribeStateUpdateResponse<nlohmann::json>, 3> _onStateUpdate;
		detail::CallbackCollection<schema::GetStateResponse<nlohmann::json>, 4> _onGetState;
		detail::CallbackCollection<schema::TwitchPurchaseBitsResponse<nlohmann::json>, 5> _onTwitchPurchaseBits;
		detail::CallbackCollection<schema::GetPollResponse, 6> _onGetPoll;
		detail::CallbackCollection<schema::DatastreamUpdate, 7> _onDatastreamUpdate;
	};
}

#endif

#endif
#ifdef MUXY_GAMELINK_SINGLE_IMPL


namespace gamelink
{
	namespace schema
	{
		SubscribeAuthenticationRequest::SubscribeAuthenticationRequest()
		{
			action = string("subscribe");
			params.target = string("authentication");
		}

		AuthenticateWithPINRequest::AuthenticateWithPINRequest(const string& client, const string& pin)
		{
			action = string("authenticate");
			params.target = string("");
			data.pin = pin;
			data.client_id = client;
		}

		AuthenticateWithJWTRequest::AuthenticateWithJWTRequest(const string& client, const string& jwt)
		{
			action = string("authenticate");
			params.target = string("");
			data.jwt = jwt;
			data.client_id = client;
		}

		User::User(string jwt)
			: jwt(std::move(jwt))
		{
		}

		const string& User::GetJWT() const
		{
			return this->jwt;
		}
	}
}




namespace gamelink
{
    namespace schema
    {
        BroadcastRequest::BroadcastRequest(const string& topic, const string& msg)
        {
            action = string("broadcast");
            params.target = string("");

            data.topic = topic;
            data.message = msg;
        }
    }
}



namespace gamelink
{
	namespace schema
	{
		SubscribeDatastreamRequest::SubscribeDatastreamRequest()
		{
			action = string("subscribe");
			params.target = string("datastream");
		}
	}
}



namespace gamelink
{
	namespace schema
	{
		JsonAtom atomFromInteger(int64_t v)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_INT64;
			atom.int64Value = v;

			return atom;
		}

		JsonAtom atomFromDouble(double v)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_DOUBLE;
			atom.doubleValue = v;

			return atom;
		}

		JsonAtom atomFromString(const string& str)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_STRING;
			atom.stringValue = str;

			return atom;
		}

		JsonAtom atomFromLiteral(const string& str)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_LITERAL;
			atom.stringValue = str;

			return atom;
		}

		JsonAtom atomNull()
		{
			JsonAtom atom;
			atom.type = JSON_ATOM_NULL;
			return atom;
		}

		void to_json(nlohmann::json& out, const JsonAtom& p)
		{
			switch (p.type)
			{
			case JSON_ATOM_NULL:
				out = nlohmann::json();
				break;
			case JSON_ATOM_INT64:
				out = p.int64Value;
				break;
			case JSON_ATOM_DOUBLE:
				out = p.doubleValue;
				break;
			case JSON_ATOM_STRING:
				out = p.stringValue;
				break;
			case JSON_ATOM_LITERAL:
				out = nlohmann::json::parse(p.stringValue.c_str(), nullptr, false);
				break;
			default:
				// Bad
				out = nlohmann::json();
				break;
			}
		}

		void from_json(const nlohmann::json& n, JsonAtom& p)
		{
			p.type = JSON_ATOM_NULL;
			if (n.is_null())
			{
				p.type = JSON_ATOM_NULL;
				return;
			}
			else if (n.is_string())
			{
				p.type = JSON_ATOM_STRING;
				p.stringValue = n.get<string>();
				return;
			}
			else if (n.is_number_integer())
			{
				p.type = JSON_ATOM_INT64;
				p.int64Value = n.get<int64_t>();
				return;
			}
			else if (n.is_number())
			{
				p.type = JSON_ATOM_DOUBLE;
				p.doubleValue = n.get<double>();
			}
			else if (n.is_object() || n.is_array())
			{
				p.type = JSON_ATOM_LITERAL;
				p.stringValue = n.dump();
			}
		}

		ReceiveMeta::ReceiveMeta()
			: request_id(0)
			, timestamp(0)
		{
		}

		SendParameters::SendParameters()
			: request_id(0xFFFF)
		{
		}

		ReceiveEnvelope<EmptyBody> ParseEnvelope(const char* bytes, uint32_t length, bool* outSuccess)
		{
			ReceiveEnvelope<EmptyBody> out;
			bool result = ParseResponse(bytes, length, out);
			if (outSuccess)
			{
				*outSuccess = result;
			}
			return out;
		}
	}
}



namespace gamelink
{
	namespace schema
	{
		GetPollRequest::GetPollRequest(const string& pollId)
		{
			action = string("get");
			params.target = string("poll");

			data.pollId = pollId;
		}

		DeletePollRequest::DeletePollRequest(const string& pollId)
		{
			action = string("delete");
			params.target = string("poll");

			data.pollId = pollId;
		}

		CreatePollRequest::CreatePollRequest(const string& pollId, const string& prompt, const std::vector<string>& options)
		{
			action = string("create");
			params.target = string("poll");

			data.pollId = pollId;
			data.prompt = prompt;
			data.options = options;
		}

		SubscribePollRequest::SubscribePollRequest(const string& pollId)
		{
			action = string("subscribe");
			params.target = string("poll");
			data.topic_id = string(pollId);
		}
	}
}



namespace gamelink
{
	namespace schema
	{
		GetStateRequest::GetStateRequest(const char* target)
		{
			action = string("get");
			params.target = string("state");
			data.state_id = string(target);
		}

		PatchStateRequest::PatchStateRequest(const char* target)
		{
			action = string("patch");
			params.target = string("state");
			data.state_id = string(target);
		}

		SubscribeStateRequest::SubscribeStateRequest(const char* target)
		{
			action = string("subscribe");
			params.target = string("state");
			data.topic_id = string(target);
		}
	}
}
#ifndef INCLUDE_MUXY_GAMELINK_CPP
#define INCLUDE_MUXY_GAMELINK_CPP


#include <cstdio>
#include <iostream>

namespace gamelink
{
	Payload::Payload(string data)
	{
		this->data = data;
	}

	SDK::SDK()
		: _user(NULL)
		, _currentRequestId(1)
		, _onDebugMessage(0, 0, detail::CALLBACK_PERSISTENT){};

	SDK::~SDK()
	{
		// Clean up unsent messages
		while (HasPayloads())
		{
			Payload* send = _queuedPayloads.front();
			_queuedPayloads.pop();
			delete send;
		}
	}

	uint16_t SDK::nextRequestId()
	{
		// Wrap around at 32k
		uint16_t id = (_currentRequestId++ & 0x7F);
		return id;
	}

	void SDK::debugLogPayload(const Payload* s)
	{
		if (_onDebugMessage.valid())
		{
			uint32_t bufferLength = s->data.size() + 128;
			char* buffer = new char[bufferLength];

			int offset = snprintf(buffer, bufferLength, "send len=%d msg=", static_cast<int>(s->data.size()));
			memcpy(buffer + offset, s->data.c_str(), s->data.size());
			buffer[s->data.size() + offset] = '\0';

			_onDebugMessage.invoke(string(buffer));

			delete[] buffer;
		}
	}

	bool SDK::HasPayloads() const
	{
		return _queuedPayloads.size() > 0;
	}

	void SDK::ForeachPayload(SDK::NetworkCallback networkCallback, void* user)
	{
		while (HasPayloads())
		{
			Payload* payload = _queuedPayloads.front();
			_queuedPayloads.pop();

			networkCallback(user, payload);

			// Clean up send
			delete payload;
		}
	}

	bool SDK::ReceiveMessage(const char* bytes, uint32_t length)
	{
		bool success = false;
		bool parseEnvelopeSuccess = false;
		schema::ReceiveEnvelope<schema::EmptyBody> env = schema::ParseEnvelope(bytes, length, &parseEnvelopeSuccess);
		if (!parseEnvelopeSuccess)
		{
			return false;
		}

		if (_onDebugMessage.valid())
		{
			uint32_t bufferLength = length + 128;
			char* buffer = new char[bufferLength];

			int offset = snprintf(buffer, bufferLength, "recv len=%d msg=", static_cast<int>(length));
			memcpy(buffer + offset, bytes, length);
			buffer[length + offset] = '\0';

			_onDebugMessage.invoke(string(buffer));

			delete[] buffer;
		}

		if (env.meta.action == "authenticate")
		{
			// Authentication response
			schema::AuthenticateResponse authResp;
			success = schema::ParseResponse(bytes, length, authResp);
			if (success)
			{
				_onAuthenticate.invoke(authResp);
				this->_user = new schema::User(authResp.data.jwt);
			}
		}
		else if (env.meta.action == "get")
		{
			if (env.meta.target == "state")
			{
				schema::GetStateResponse<nlohmann::json> stateResp;
				success = schema::ParseResponse(bytes, length, stateResp);

				if (success)
				{
					_onGetState.invoke(stateResp);
				}
			}

			if (env.meta.target == "poll")
			{
				schema::GetPollResponse pollResp;
				success = schema::ParseResponse(bytes, length, pollResp);

				if (success)
				{
					_onGetPoll.invoke(pollResp);
				}
			}
		}
		else if (env.meta.action == "update")
		{
			if (env.meta.target == "poll")
			{
				// Poll update response
				// TODO Handle a UserDataPollUpdateResponse as well
				schema::PollUpdateResponse pollResp;
				success = schema::ParseResponse<schema::PollUpdateResponse>(bytes, length, pollResp);
				if (success)
				{
					_onPollUpdate.invoke(pollResp);
				}
			}
			else if (env.meta.target == "channel")
			{
				schema::SubscribeStateUpdateResponse<nlohmann::json> resp;

				success = schema::ParseResponse(bytes, length, resp);
				if (success)
				{
					_onStateUpdate.invoke(resp);
				}
			}
			else if (env.meta.target == "twitchBitsPurchase")
			{
				schema::TwitchPurchaseBitsResponse<nlohmann::json> resp;
				success = schema::ParseResponse(bytes, length, resp);
				if (success)
				{
					_onTwitchPurchaseBits.invoke(resp);
				}
			}
			else if (env.meta.target == "datastream")
			{
				schema::DatastreamUpdate resp;
				success = schema::ParseResponse(bytes, length, resp);
				if (success)
				{
					_onDatastreamUpdate.invoke(resp);
				}
			}
		}

		return success;
	}

	bool SDK::IsAuthenticated() const
	{
		return _user != NULL;
	}

	const schema::User* SDK::GetUser() const
	{
		return _user;
	}

	// Callbacks
	void SDK::OnDebugMessage(std::function<void(const string&)> callback)
	{
		_onDebugMessage.set(callback);
	}

	void SDK::OnDebugMessage(void (*callback)(void*, const string&), void* ptr)
	{
		_onDebugMessage.set(callback, ptr);
	}

	void SDK::DetachOnDebugMessage()
	{
		_onDebugMessage.clear();
	}

	uint32_t SDK::OnPollUpdate(std::function<void(const schema::PollUpdateResponse& pollResponse)> callback)
	{
		return _onPollUpdate.set(callback, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnPollUpdate(void (*callback)(void*, const schema::PollUpdateResponse&), void* ptr)
	{
		return _onPollUpdate.set(callback, ptr, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnPollUpdate(uint32_t id)
	{
		if (_onPollUpdate.validateId(id))
		{
			_onPollUpdate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnPollUpdate");
		}
	}

	uint32_t SDK::OnAuthenticate(std::function<void(const schema::AuthenticateResponse&)> callback)
	{
		return _onAuthenticate.set(callback, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnAuthenticate(void (*callback)(void*, const schema::AuthenticateResponse&), void* ptr)
	{
		return _onAuthenticate.set(callback, ptr, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnAuthenticate(uint32_t id)
	{
		if (_onAuthenticate.validateId(id))
		{
			_onAuthenticate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnAuthenticate");
		}
	}

	uint32_t SDK::OnStateUpdate(std::function<void(const schema::SubscribeStateUpdateResponse<nlohmann::json>&)> callback)
	{
		return _onStateUpdate.set(callback, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnStateUpdate(void (*callback)(void*, const schema::SubscribeStateUpdateResponse<nlohmann::json>&), void* ptr)
	{
		return _onStateUpdate.set(callback, ptr, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnStateUpdate(uint32_t id)
	{
		if (_onStateUpdate.validateId(id))
		{
			_onStateUpdate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into OnStateUpdate");
		}
	}

	uint32_t SDK::OnTwitchPurchaseBits(std::function<void(const schema::TwitchPurchaseBitsResponse<nlohmann::json>&)> callback)
	{
		return _onTwitchPurchaseBits.set(callback, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnTwitchPurchaseBits(void (*callback)(void*, const schema::TwitchPurchaseBitsResponse<nlohmann::json>&), void* ptr)
	{
		return _onTwitchPurchaseBits.set(callback, ptr, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnTwitchPurchaseBits(uint32_t id)
	{
		if (_onTwitchPurchaseBits.validateId(id))
		{
			_onTwitchPurchaseBits.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnTwitchPurchaseBits");
		}
	}

	void SDK::AuthenticateWithPIN(const string& clientId, const string& pin)
	{
		schema::AuthenticateWithPINRequest payload(clientId, pin);
		queuePayload(payload);
	}

	void
	SDK::AuthenticateWithPIN(const string& clientId, const string& pin, std::function<void(const schema::AuthenticateResponse&)> callback)
	{
		schema::AuthenticateWithPINRequest payload(clientId, pin);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onAuthenticate.set(callback, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::AuthenticateWithPIN(const string& clientId,
								  const string& pin,
								  void (*callback)(void*, const schema::AuthenticateResponse&),
								  void* user)
	{
		schema::AuthenticateWithPINRequest payload(clientId, pin);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onAuthenticate.set(callback, user, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::AuthenticateWithJWT(const string& clientId, const string& jwt)
	{
		schema::AuthenticateWithJWTRequest payload(clientId, jwt);
		queuePayload(payload);
	}

	void
	SDK::AuthenticateWithJWT(const string& clientId, const string& jwt, std::function<void(const schema::AuthenticateResponse&)> callback)
	{
		schema::AuthenticateWithJWTRequest payload(clientId, jwt);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onAuthenticate.set(callback, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::AuthenticateWithJWT(const string& clientId,
								  const string& jwt,
								  void (*callback)(void*, const schema::AuthenticateResponse&),
								  void* user)
	{
		schema::AuthenticateWithJWTRequest payload(clientId, jwt);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onAuthenticate.set(callback, user, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::GetPoll(const string& pollId)
	{
		schema::GetPollRequest packet(pollId);
		queuePayload(packet);
	}

	void SDK::GetPoll(const string& pollId, std::function<void(const schema::GetPollResponse&)> callback)
	{
		schema::GetPollRequest payload(pollId);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onGetPoll.set(callback, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::GetPoll(const string& pollId, void (*callback)(void*, const schema::GetPollResponse&), void* user)
	{
		schema::GetPollRequest payload(pollId);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onGetPoll.set(callback, user, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::CreatePoll(const string& pollId, const string& prompt, const std::vector<string>& options)
	{
		schema::CreatePollRequest packet(pollId, prompt, options);
		queuePayload(packet);
	}

	void SDK::SubscribeToPoll(const string& pollId)
	{
		schema::SubscribePollRequest packet(pollId);
		queuePayload(packet);
	}

	void SDK::DeletePoll(const string& pollId)
	{
		schema::DeletePollRequest payload(pollId);
		queuePayload(payload);
	}

	void SDK::SetState(const char* target, const nlohmann::json& value)
	{
		schema::SetStateRequest<nlohmann::json> payload(target, value);
		queuePayload(payload);
	}

	void SDK::GetState(const char* target)
	{
		schema::GetStateRequest payload(target);
		queuePayload(payload);
	}

	void SDK::GetState(const char* target, std::function<void(const schema::GetStateResponse<nlohmann::json>&)> callback)
	{
		schema::GetStateRequest payload(target);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onGetState.set(callback, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::GetState(const char* target, void (*callback)(void*, const schema::GetStateResponse<nlohmann::json>&), void* user)
	{
		schema::GetStateRequest payload(target);
		uint16_t id = nextRequestId();

		payload.params.request_id = id;
		queuePayload(payload);

		_onGetState.set(callback, user, id, detail::CALLBACK_ONESHOT);
	}

	void SDK::SubscribeToStateUpdates(const char* target)
	{
		schema::SubscribeStateRequest payload(target);
		queuePayload(payload);
	}

	void SDK::UpdateState(const char* target, const string& operation, const string& path, const schema::JsonAtom& atom)
	{
		schema::PatchOperation op;
		op.operation = operation;
		op.path = path;
		op.value = atom;

		UpdateState(target, &op, &op + 1);
	}

	void SDK::UpdateState(const char* target, const schema::PatchOperation* begin, const schema::PatchOperation* end)
	{
		schema::PatchStateRequest payload(target);
		std::vector<schema::PatchOperation> updates;
		updates.resize(end - begin);
		std::copy(begin, end, updates.begin());

		payload.data.state = std::move(updates);
		queuePayload(payload);
	};

	void SDK::SendBroadcast(const string& target, const nlohmann::json& msg)
	{
		schema::BroadcastRequest payload(target, msg.dump());
		queuePayload(payload);
	}

	void SDK::SubscribeToDatastream()
	{
		schema::SubscribeDatastreamRequest payload;
		queuePayload(payload);
	}

	uint32_t SDK::OnDatastream(std::function<void(const schema::DatastreamUpdate&)> callback)
	{
		return _onDatastreamUpdate.set(callback, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnDatastream(void (*callback)(void*, const schema::DatastreamUpdate&), void* user)
	{
		return _onDatastreamUpdate.set(callback, user, detail::ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnDatastream(uint32_t id)
	{
		if (_onDatastreamUpdate.validateId(id))
		{
			_onDatastreamUpdate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnDatastream");
		}
	}
}

#endif

#endif
