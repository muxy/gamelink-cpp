/* This file is automatically generated from multiple sources. Do not modify */


#ifndef MUXY_GAMELINK_SINGLE_HPP
#define MUXY_GAMELINK_SINGLE_HPP

#ifndef MUXY_GAMELINK_CONFIG_H
#define MUXY_GAMELINK_CONFIG_H

// Support custom string types.
#ifndef MUXY_GAMELINK_CUSTOM_STRING_TYPE
#	include <string>
#	define MUXY_GAMELINK_CUSTOM_STRING_TYPE std::string
#else
#	define MUXY_GAMELINK_REQUIRES_STRING_JSON_OVERLOAD 1
#endif

#ifdef MUXY_GAMELINK_CUSTOM_STRING_INCLUDE
#include MUXY_GAMELINK_CUSTOM_STRING_INCLUDE
#endif

// Support custom lock types. 
#ifndef MUXY_GAMELINK_CUSTOM_LOCK_TYPE
#include <mutex>
#define MUXY_GAMELINK_CUSTOM_LOCK_TYPE std::mutex
#endif

#ifdef MUXY_GAMELINK_CUSTOM_LOCK_INCLUDE
#include MUXY_GAMELINK_CUSTOM_LOCK_INCLUDE
#endif

#ifndef NO_JSON_INCLUDE
#include <nlohmann/json.hpp>
#endif

namespace gamelink
{
	/// This can be controlled by defining `MUXY_GAMELINK_CUSTOM_STRING_TYPE`.
	/// By default, MUXY_GAMELINK_CUSTOM_STRING_TYPE is std::string
	/// This string should
	///     * Have a default constructor that creates an empty ("") string.
	///     * Be Copy constructable and copy assignable.
	///     * Be Move constructable and move assignable.
	///     * Provide a constructor from a null-terminated c-string of chars
	///     * Provide const operator== with another const reference of the string type. 
	///     * Provide a const .size() that returns an integer of the length of the string, 
	///       excluding any null terminator. This should return an uint32_t.
	///     * Provide a const .c_str() that returns a pointer to the first element of a
	///       null-terminated array of utf8 encoded chars.
	typedef MUXY_GAMELINK_CUSTOM_STRING_TYPE string;

	/// This can be controlled by defining `MUXY_GAMELINK_CUSTOM_LOCK_TYPE`
	/// By default, MUXY_GAMELINK_CUSTOM_LOCK_TYPE is std::mutex
	/// This lock type should
	///     * Have a default constructor that creates a valid, unlocked lock.
	///     * May be uncopyable and unmovable.
	/// 	* Provide .lock(), .unlock() and bool .try_lock()
	/// 	* .try_lock() should true upon lock aquisition, and false otherwise.
	///     * Does not have to be recursive
	typedef MUXY_GAMELINK_CUSTOM_LOCK_TYPE lock;
}

#ifdef MUXY_GAMELINK_REQUIRES_STRING_JSON_OVERLOAD
namespace nlohmann
{
	template<>
	struct adl_serializer<gamelink::string> 
	{
		static void to_json(json& j, const gamelink::string& s)
		{
			j = json::string_t(s.c_str());
		}

		static void from_json(const json& j, gamelink::string& s)
		{
			s = gamelink::string(j.get<json::string_t>().c_str());
		}
	};
}
#endif

#endif



#ifndef MUXY_GAMELINK_SCHEMA_SERIALIZATION_H
#define MUXY_GAMELINK_SCHEMA_SERIALIZATION_H

#define MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, name, out, property)                                                                        \
	{                                                                                                                                      \
		nlohmann::json::const_iterator it = in.find(name);                                                                                 \
		if (it != in.end())                                                                                                                \
		{                                                                                                                                  \
			it->get_to(out.property);                                                                                                      \
		}                                                                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_0(Type)                                                                                                    \
	inline void to_json(nlohmann::json& out, const Type& p) {}                                                                             \
	inline void from_json(const nlohmann::json& in, Type& p) {}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_0(Type)                                                                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p) {}                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p) {}

#define MUXY_GAMELINK_SERIALIZE_1(Type, n1, p1)                                                                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(Type, n1, p1)                                                                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_2(Type, n1, p1, n2, p2)                                                                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(Type, n1, p1, n2, p2)                                                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_3(Type, n1, p1, n2, p2, n3, p3)                                                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(Type, n1, p1, n2, p2, n3, p3)                                                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_4(Type, n1, p1, n2, p2, n3, p3, n4, p4)                                                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_4(Type, n1, p1, n2, p2, n3, p3, n4, p4)                                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_5(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5)                                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_5(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5)                                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_6(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6)                                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_6(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6)                                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_7(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7)                                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_7(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7)                                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_8(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8)                                    \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_8(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8)                          \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_9(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9)                            \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_9(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9)                  \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
	}

#define MUXY_GAMELINK_SERIALIZE_10(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9, n10, p10)                 \
	inline void to_json(nlohmann::json& out, const Type& p)                                                                                \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
		out[n10] = p.p10;                                                                                                                  \
	}                                                                                                                                      \
	inline void from_json(const nlohmann::json& in, Type& p)                                                                               \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n10, p, p10)                                                                                \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_10(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9, n10, p10)       \
	friend inline void to_json(nlohmann::json& out, const Type& p)                                                                         \
	{                                                                                                                                      \
		out[n1] = p.p1;                                                                                                                    \
		out[n2] = p.p2;                                                                                                                    \
		out[n3] = p.p3;                                                                                                                    \
		out[n4] = p.p4;                                                                                                                    \
		out[n5] = p.p5;                                                                                                                    \
		out[n6] = p.p6;                                                                                                                    \
		out[n7] = p.p7;                                                                                                                    \
		out[n8] = p.p8;                                                                                                                    \
		out[n9] = p.p9;                                                                                                                    \
		out[n10] = p.p10;                                                                                                                  \
	}                                                                                                                                      \
	friend inline void from_json(const nlohmann::json& in, Type& p)                                                                        \
	{                                                                                                                                      \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9)                                                                                  \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n10, p, p10)                                                                                \
	}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_ENVELOPE_H
#define MUXY_GAMELINK_SCHEMA_ENVELOPE_H



namespace gamelink
{
	namespace schema
	{
		// A JSON atom reprsents one of the 4 supported base types of json value -
		// An integer, double, string, null
		enum JsonAtomType
		{
			JSON_ATOM_NULL,    //!< No fields are valid, the JSONAtom represents a null
			JSON_ATOM_INT64,   //!< The int64Value field is valid, and the JSONAtom represents an integer.
			JSON_ATOM_DOUBLE,  //!< The doubleValue field is valid, and the JSONAtom represents a double.
			JSON_ATOM_STRING,  //!< The stringValue field is valid, and the JSONAtom represents a string.
			JSON_ATOM_LITERAL, //!< The stringValue field is valid, and is a JSON encoded object or array.

			JSON_ATOM_FORCE_32 = 0xFFFFFFFF
		};

		/// JSONAtom is effectively a tagged union that can contain a signed 64-bit integer,
		/// a floating point double, a string, a json literal, or null. The type of a JSONAtom is stored in
		/// the `field` type.
		struct JsonAtom
		{
			/// Type of the contained value
			JsonAtomType type;

			/// Integer value
			int64_t int64Value;

			/// Double value
			double doubleValue;

			/// String value
			string stringValue;
		};

		/// Creates a JsonAtom that represents an integer
		/// @param[in] v Integer value
		/// @return JsonAtom that contains the input integer value
		JsonAtom atomFromInteger(int64_t v);

		/// Creates a JsonAtom that represents a double
		/// @param[in] d Double value
		/// @return JsonAtom that contains the input double value
		JsonAtom atomFromDouble(double d);

		/// Creates a JsonAtom that represents a string
		/// @param[in] str String value
		/// @return JsonAtom that contains the input string value
		JsonAtom atomFromString(const string& str);

		/// Creates a JsonAtom that represents an object
		/// @param[in] str JSON Literal
		/// @return JsonAtom that contains the input literal
		JsonAtom atomFromLiteral(const string& str);

		/// Creates a JsonAtom that represents null
		/// @return A null JsonAtom
		JsonAtom atomNull();

		void to_json(nlohmann::json& out, const JsonAtom& p);
		void from_json(const nlohmann::json& in, JsonAtom& p);

		/// Contains metadata fields about a response
		struct ReceiveMeta
		{
			ReceiveMeta();

			/// Request ID, as sent by the response
			uint16_t request_id;

			/// Action of the request
			string action;

			/// Target of the request
			string target;

			/// Unix timestamp in milliseconds since epoch.
			uint64_t timestamp;
		};

		MUXY_GAMELINK_SERIALIZE_4(ReceiveMeta, "request_id", request_id, "action", action, "target", target, "timestamp", timestamp)

		/// Error type, possibly returned by any API call.
		struct Error
		{
			/// Unsigned error code. Correlates to HTTP error codes.
			uint32_t number;

			/// Human readable error title.
			string title;

			/// Human readable detail field.
			string detail;
		};

		MUXY_GAMELINK_SERIALIZE_3(Error, "number", number, "title", title, "detail", detail)

		/// ReceiveEnvelope
		template<typename T>
		struct ReceiveEnvelope
		{
			/// Metadata about this response
			ReceiveMeta meta;

			/// Data field. Will vary based on the response.
			/// See the type documentation for more details.
			T data;

			/// Errors list. Mutually exclusive with data.
			/// May contain more than one error.
			std::vector<Error> errors;
		};

		template<typename T>
		void to_json(nlohmann::json& out, const ReceiveEnvelope<T>& p)
		{
			out["meta"] = p.meta;
			out["data"] = p.data;

			if (p.errors.size())
			{
				out["errors"] = p.errors;
			}
		}

		template<typename T>
		void from_json(const nlohmann::json& in, ReceiveEnvelope<T>& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "meta", p, meta);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "data", p, data);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "errors", p, errors);
		}

		struct SendParameters
		{
			SendParameters();

			/// Request ID. Will be echoed back in the response.
			/// By default, is 0xFFFF
			uint16_t request_id;

			/// Target field. Will vary in behavior based on action.
			string target;
		};

		inline void to_json(nlohmann::json& out, const SendParameters& p)
		{
			out["request_id"] = p.request_id;
			if (p.target.size())
			{
				out["target"] = p.target;
			}
		}

		inline void from_json(const nlohmann::json& in, SendParameters& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "request_id", p, request_id);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "target", p, target);
		}

		template<typename T>
		struct SendEnvelope
		{
			/// The action of this request.
			string action;

			/// Parameters of this request.
			SendParameters params;

			/// Data field. Will vary based on the response.
			/// See the type documentation for more details.
			T data;
		};

		template<typename T>
		void to_json(nlohmann::json& out, const SendEnvelope<T>& p)
		{
			out["action"] = p.action;
			out["params"] = p.params;
			out["data"] = p.data;
		}

		template<typename T>
		void from_json(const nlohmann::json& in, SendEnvelope<T>& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "action", p, action);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "params", p, params);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "data", p, data);
		}

		template<typename T>
		std::string to_string(const SendEnvelope<T>& p)
		{
			nlohmann::json out;
			to_json(out, p);
			return out.dump();
		}

		/// The empty body. Has no members.
		struct EmptyBody
		{
		};

		/// OKResponseBody is sent back when a simple operation succeeds.
		struct OKResponseBody
		{
			/// Will always be 'true'. If an error occurred, then
			/// the errors array in the response would be set.
			bool ok;
		};

		MUXY_GAMELINK_SERIALIZE_1(OKResponseBody, "ok", ok)

		// Specialization for empty body serialization
		MUXY_GAMELINK_SERIALIZE_2(SendEnvelope<EmptyBody>, "action", action, "params", params);
		MUXY_GAMELINK_SERIALIZE_2(ReceiveEnvelope<EmptyBody>, "meta", meta, "errors", errors);

		/// Parse a response object
		/// @param[in] bytes JSON input bytes. Must not be null.
		/// @param[in] length Length of the bytes parameter
		/// @param[out] out Output object. Should be a ResponseEnvelope or a type inherited from ResponseEnvelope.
		/// @return true iff the input JSON parsed correctly, false otherwise
		template<typename T>
		bool ParseResponse(const char* bytes, uint32_t length, T& out)
		{
			nlohmann::json value = nlohmann::json::parse(bytes, bytes + length, nullptr, false);
			if (value.is_discarded())
			{
				return false;
			}

			from_json(value, out);
			return true;
		}

		/// Parses a ReceiveEnvelope only. Does not attempt to parse the body.
		/// @param[in] bytes JSON input bytes. Must not be null.
		/// @param[in] length Length of the bytes parameter
		/// @param[out] success Optional boolean to determine parse failure. Will be set to true iff the parse succeeded, false otherwise.
		/// @return A ReceiveEnvelope with no body, only metadata field and possibly errors.
		ReceiveEnvelope<EmptyBody> ParseEnvelope(const char* bytes, uint32_t length, bool* success = nullptr);
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_SUBSCRIPTION_H
#define MUXY_GAMELINK_SCHEMA_SUBSCRIPTION_H

namespace gamelink
{
	namespace schema
	{
		struct SubscribeTopicRequestBody
		{
			string topic_id;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(SubscribeTopicRequestBody, "topic_id", topic_id);
		};

		struct UnsubscribeTopicRequestBody
		{
			string topic_id;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(UnsubscribeTopicRequestBody, "topic_id", topic_id);
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_AUTHENTICATION_H
#define MUXY_GAMELINK_SCHEMA_AUTHENTICATION_H


namespace gamelink
{
	namespace schema
	{
		struct AuthenticateWithPINRequestBody
		{
			/// PIN string, as obtained from the REST API
			string pin;

			/// Client ID, as obtained from Twitch.
			string client_id;
		};
		MUXY_GAMELINK_SERIALIZE_2(AuthenticateWithPINRequestBody, "pin", pin, "client_id", client_id);

		struct AuthenticateWithJWTRequestBody
		{
			/// JWT string, as obtained from previous authorizations
			string jwt;

			/// Client ID, as obtained from Twitch.
			string client_id;
		};
		MUXY_GAMELINK_SERIALIZE_2(AuthenticateWithJWTRequestBody, "jwt", jwt, "client_id", client_id);

		struct AuthenticateJWTResponseBody
		{
			/// Signed JWT. Will expire.
			string jwt;
		};
		MUXY_GAMELINK_SERIALIZE_1(AuthenticateJWTResponseBody, "jwt", jwt);

		struct SubscribeAuthenticationRequest : SendEnvelope<EmptyBody>
		{
			SubscribeAuthenticationRequest();
		};

		struct SubscribeAuthenticationResponse : ReceiveEnvelope<OKResponseBody>
		{
		};

		struct AuthenticateWithPINRequest : SendEnvelope<AuthenticateWithPINRequestBody>
		{
			/// Creates an authorization request.
			/// @param[in] clientID Client ID.
			/// @param[in] pin PIN obtained from user input.
			AuthenticateWithPINRequest(const string& clientID, const string& pin);
		};

		struct AuthenticateWithJWTRequest : SendEnvelope<AuthenticateWithJWTRequestBody>
		{
			/// Creates an authorization request
			/// @param[in] clientID Client ID.
			/// @param[in] jwt JWT obtained from previous authorizations.
			AuthenticateWithJWTRequest(const string& clientID, const string& jwt);
		};

		struct AuthenticateResponse : ReceiveEnvelope<AuthenticateJWTResponseBody>
		{
		};

		class User
		{
		public:
			explicit User(string jwt);

			const string& GetJWT() const;
			// string GetOpaqueID();
		private:
			string jwt;
		};
	}
}
#endif


#ifndef MUXY_GAMELINK_SCHEMA_BROADCAST_H
#define MUXY_GAMELINK_SCHEMA_BROADCAST_H


namespace gamelink
{
    namespace schema
    {
        template<typename T>
        struct BroadcastRequestBody
        {
            T data;
            string topic;

            MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(BroadcastRequestBody, "data", data, "topic", topic);
        };

        template<typename T>
        struct BroadcastRequest : SendEnvelope<BroadcastRequestBody<T>>
        {
            BroadcastRequest(const string& topic, const T& data)
            {
                this->action = string("broadcast");
                this->params.target = string("");

                this->data.topic = topic;
                this->data.data = data;
            }
        };

        struct BroadcastResponse : ReceiveEnvelope<OKResponseBody>
        {};
    }
}

#endif

#ifndef MUXY_GAMELINK_SCHEMA_DATASTREAM_H
#define MUXY_GAMELINK_SCHEMA_DATASTREAM_H



namespace gamelink
{
	namespace schema
	{
		struct DatastreamEvent
		{
			nlohmann::json event;
			int64_t timestamp;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(DatastreamEvent, "event", event, "timestamp", timestamp);
		};

		struct DatastreamUpdateBody
		{
			std::vector<DatastreamEvent> events;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(DatastreamUpdateBody, "events", events);
		};

		struct DatastreamUpdate : ReceiveEnvelope<DatastreamUpdateBody>
		{
		};

		struct SubscribeDatastreamRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribeDatastreamRequest
			explicit SubscribeDatastreamRequest();
		};

		struct UnsubscribeDatastreamRequest : SendEnvelope<UnsubscribeTopicRequestBody>
		{
			/// Creates an UnsubscribeDatastreamRequest
			explicit UnsubscribeDatastreamRequest();
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_POLL_H
#define MUXY_GAMELINK_SCHEMA_POLL_H



namespace gamelink
{
	namespace schema
	{
		struct GetPollRequestBody
		{
			/// The Poll ID to get
			string pollId;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(GetPollRequestBody, "poll_id", pollId);
		};

		struct DeletePollRequestBody
		{
			string pollId;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(DeletePollRequestBody, "poll_id", pollId);
		};

		struct CreatePollRequestBody
		{
			/// The Poll ID to create. Poll IDs are scoped to the current channel.
			string pollId;

			/// The poll prompt
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(CreatePollRequestBody, "poll_id", pollId, "prompt", prompt, "options", options);
		};

		template<typename T>
		struct CreatePollWithUserDataRequestBody
		{
			/// The Poll ID to create
			string pollId;

			/// The prompt for the poll.
			string prompt;

			/// An array of options for the poll
			std::vector<string> options;

			/// Arbitrary serializable user data.
			T userData;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_4(CreatePollWithUserDataRequestBody,
												"poll_id",
												pollId,
												"prompt",
												prompt,
												"options",
												options,
												"user_data",
												userData);
		};

		struct PollResponseBody
		{
			/// The Poll ID that the update is for
			string pollId;

			/// The prompt for the poll.
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollResponseBody, "poll_id", pollId, "prompt", prompt, "options", options);
		};

		template<typename T>
		struct PollWithUserDataResponseBody
		{
			/// The prompt for the poll.
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			/// Arbitrary user data type. Must be marked up with the MUXY_GAMELINK_SERIALIZE macro.
			T userData;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollWithUserDataResponseBody, "prompt", prompt, "options", options, "user_data", userData);
		};

		// Note that this is the same as PollUpdateBody, and is provided for consistency with each 
		// endpoint having their own envelope with body.
		struct GetPollResponseBody
		{
			/// The poll information
			PollResponseBody poll;

			/// Array of vote counts for each poll option. This array may not be the same size as the
			/// options array.
			std::vector<int> results;

			/// Arithmetic mean of all poll values, including ones that outside the [0, 32) range.
			double mean;

			/// Sum of all poll values, including ones that outside the [0, 32) range.
			double sum;

			/// Number of responses, including ones that outside the [0, 32) range.
			int32_t count;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_5(GetPollResponseBody, "poll", poll, "results", results, "mean", mean, "sum", sum, "count", count);
		};

		struct PollUpdateBody
		{
			/// The poll information
			PollResponseBody poll;

			/// Array of vote counts for each poll option. This array may not be the same size as the
			/// options array.
			std::vector<int> results;

			/// Arithmetic mean of all poll values, including ones that outside the [0, 32) range.
			double mean;

			/// Sum of all poll values, including ones that outside the [0, 32) range.
			double sum;

			/// Number of responses, including ones that outside the [0, 32) range.
			int32_t count;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_5(PollUpdateBody, "poll", poll, "results", results, "mean", mean, "sum", sum, "count", count);
		};

		template<typename T>
		struct PollWithUserDataUpdateBody
		{
			/// The Poll ID that this update represents
			string pollId;

			/// The poll prompt and options.
			PollWithUserDataResponseBody<T> poll;

			/// An array of vote counts for each poll option. This array may not be the same
			/// size as the options array.
			std::vector<int> results;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollWithUserDataUpdateBody, "topic_id", pollId, "poll", poll, "results", results);
		};

		struct GetPollRequest : SendEnvelope<GetPollRequestBody>
		{
			/// Creates a GetPoll request
			/// @param[in] pollId The ID of the poll to get. Maximum size 64 characters.
			explicit GetPollRequest(const string& pollId);
		};

		struct CreatePollRequest : SendEnvelope<CreatePollRequestBody>
		{
			/// Creates a CreatePoll request.
			/// @param[in] pollId The ID of the poll to create. This can overwrite existing polls if the same
			///                   id is specified.
			/// @param[in] prompt The prompt for the poll to create.
			/// @param[in] options vector of options for the poll.
			CreatePollRequest(const string& pollId, const string& prompt, const std::vector<string>& options);
		};

		template<typename T>
		struct CreatePollWithUserDataRequest : SendEnvelope<CreatePollWithUserDataRequestBody<T>>
		{
			/// Creates a CreatePoll request, but with user data.
			/// @param[in] pollId The ID of the poll to create. This can overwrite existing polls if the same
			///                   id is specified.
			/// @param[in] prompt The prompt for the poll to create.
			/// @param[in] options vector of options for the poll.
			/// @param[in] userData Arbitrary user data to attach to this poll. This type should be serializable. The fully marshalled
			///                     size of this type should be under 1kb.
			CreatePollWithUserDataRequest(const string& pollId, const string& prompt, const std::vector<string>& options, const T& userData)
			{
				this->action = string("create");
				this->params.target = string("poll");

				this->data.pollId = pollId;
				this->data.prompt = prompt;
				this->data.options = options;

				this->data.userData = userData;
			}
		};

		struct SubscribePollRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribePollRequest.
			/// @param[in] pollId The ID of the poll to subscribe to updates for.
			explicit SubscribePollRequest(const string& pollId);
		};
		
		struct UnsubscribePollRequest : SendEnvelope<UnsubscribeTopicRequestBody>
		{
			/// Creates an UnsubscribePollRequest.
			/// @param[in] pollId The ID of the poll to subscribe to updates for.
			explicit UnsubscribePollRequest(const string& pollId);
		};


		struct PollUpdateResponse : ReceiveEnvelope<PollUpdateBody>
		{
		};

		struct GetPollResponse : ReceiveEnvelope<GetPollResponseBody>
		{
		};

		template<typename T>
		struct PollWithUserDataUpdateResponse : ReceiveEnvelope<PollWithUserDataUpdateBody<T>>
		{
		};

		struct DeletePollRequest : SendEnvelope<DeletePollRequestBody>
		{
			/// Creates a DeletePoll request
			/// @param[in] pollId 	The ID of the poll to be deleted.
			explicit DeletePollRequest(const string& pollId);
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_PURCHASE_H
#define MUXY_GAMELINK_SCHEMA_PURCHASE_H



namespace gamelink
{
	namespace schema
	{
		template<typename T>
		struct TwitchPurchaseBitsResponseBody
		{
            string id;
			string sku;
			string displayName;
			string userId;
			string username;

			int cost;
            int64_t timestamp;

			T additional;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_8(TwitchPurchaseBitsResponseBody,
												"id", 
												id,
												"sku",
												sku,
												"displayName",
												displayName,
												"userId",
												userId,
												"username",
												username,
												"cost", 
												cost, 
												"timestamp", 
												timestamp,
												"additional",
												additional);
		};

		template<typename T>
		struct TwitchPurchaseBitsResponse : ReceiveEnvelope<TwitchPurchaseBitsResponseBody<T>>
		{
		};


		struct SubscribePurchaseRequestBody
		{
			string sku;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(SubscribePurchaseRequestBody, "sku", sku);
		};

		struct UnsubscribePurchaseRequestBody
		{
			string sku;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(UnsubscribePurchaseRequestBody, "sku", sku);
		};
		
		struct SubscribeTransactionsRequest : SendEnvelope<SubscribePurchaseRequestBody>
		{
			/// Creates a SubscribeTransactionsRequest
			explicit SubscribeTransactionsRequest(const string& SKU);
		};

		struct UnsubscribeTransactionsRequest : SendEnvelope<UnsubscribePurchaseRequestBody>
		{
			/// Creates an UnsubscribeTransactionsRequest
			explicit UnsubscribeTransactionsRequest(const string& SKU);
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_H
#define MUXY_GAMELINK_SCHEMA_H










#endif


#ifndef MUXY_GAMELINK_SCHEMA_STATE_H
#define MUXY_GAMELINK_SCHEMA_STATE_H



namespace gamelink
{
	namespace schema
	{
		// Set / Get state
		template<typename T>
		struct SetStateRequestBody
		{
			/// Either 'channel' or 'extension', based on the target.
			string state_id;

			/// The state to set. The type `T` should be serializable
			/// through use of the MUXY_GAMELINK_SERIALIZE macros.
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(SetStateRequestBody, "state_id", state_id, "state", state);
		};

		template<typename T>
		struct StateResponseBody
		{
			/// Will always be true.
			bool ok;

			/// State response. The type `T` should be serializable
			/// through use of the MUXY_GAMELINK_SERIALIZE macros.
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(StateResponseBody, "ok", ok, "state", state);
		};

		/// Channel State target
		static const char* STATE_TARGET_CHANNEL = "channel";

		/// Extension State target
		static const char* STATE_TARGET_EXTENSION = "extension";

		template<typename T>
		struct SetStateRequest : SendEnvelope<SetStateRequestBody<T>>
		{
			/// Creates a SetState request.
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			/// @param[in] value A serializable type.
			SetStateRequest(const char* target, const T& value)
			{
				this->action = string("set");
				this->params.target = string("state");
				this->data.state_id = string(target);
				this->data.state = value;
			}
		};

		template<typename T>
		struct SetStateResponse : ReceiveEnvelope<StateResponseBody<T>>
		{
		};

		struct GetStateRequestBody
		{
			/// Either 'channel' or 'extension', based on the target.
			string state_id;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(GetStateRequestBody, "state_id", state_id);
		};

		struct GetStateRequest : SendEnvelope<GetStateRequestBody>
		{
			/// Creates a GetState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit GetStateRequest(const char* target);
		};

		template<typename T>
		struct GetStateResponse : ReceiveEnvelope<StateResponseBody<T>>
		{
		};

		// Update state
		struct PatchOperation
		{
			string operation;
			string path;
			JsonAtom value;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PatchOperation, "op", operation, "path", path, "value", value);
		};

		struct PatchStateRequestBody
		{
			/// Either 'channel' or 'extension', based on the target.
			string state_id;

			std::vector<PatchOperation> state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(PatchStateRequestBody, "state_id", state_id, "state", state);
		};

		struct PatchStateRequest : SendEnvelope<PatchStateRequestBody>
		{
			/// Creates an UpdateState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit PatchStateRequest(const char* target);
		};

		// Subscription
		template<typename T>
		struct StateUpdateBody
		{
			string topic_id;
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(StateUpdateBody, "topic_id", topic_id, "state", state);
		};

		struct SubscribeStateRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribeState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit SubscribeStateRequest(const char* target);
		};

		template<typename T>
		struct SubscribeStateUpdateResponse : ReceiveEnvelope<StateUpdateBody<T>>
		{
		};
	}
}
#endif


#ifndef INCLUDE_MUXY_GAMELINK_H
#define INCLUDE_MUXY_GAMELINK_H


#include <deque>

namespace gamelink
{
	/// FirstError gets a pointer to the first error in the errors array in a
	/// receive envelope if it exists.
	///
	/// @param[in] recv A receive envelope
	/// @returns Pointer to first error in the errors array of the envelope. If no
	///          such error exists, returns the null pointer.
	template<typename T>
	const schema::Error* FirstError(const schema::ReceiveEnvelope<T>& recv)
	{
		if (recv.errors.empty())
		{
			return NULL;
		}

		return &recv.errors[0];
	}

	/// RequestId is an 16bit unsigned integer that represents a request.
	/// Obtained through SDK methods.
	typedef uint16_t RequestId;

	/// Constant RequestId that represents the "don't care" request id.
	static const RequestId ANY_REQUEST_ID = 0xFFFF;

	/// Payload represents a block of data to be sent through the websocket.
	class Payload
	{
		friend class SDK;
		explicit Payload(string data);
		RequestId waitingForResponse;
	public:
		/// Data to be sent. 
		const string data;
	};

	namespace detail
	{
		static const uint32_t CALLBACK_PERSISTENT = 0;
		static const uint32_t CALLBACK_ONESHOT = 1;
		static const uint32_t CALLBACK_REMOVED = 2;

		template<typename T>
		class Callback
		{
		public:
			typedef void (*RawFunctionPointer)(void*, const T&);

			Callback(uint32_t id, RequestId targetRequestId, uint32_t status)
				: _id(id)
				, _targetRequestId(targetRequestId)
				, _status(status)
				, _rawCallback(nullptr)
				, _user(nullptr)
			{
			}

			void invoke(const T& v)
			{
				if (_rawCallback)
				{
					_rawCallback(_user, v);
				}
				else if (_callback)
				{
					_callback(v);
				}
			}

			void set(std::function<void(const T&)> fn)
			{
				_rawCallback = nullptr;
				_user = nullptr;

				_callback = fn;
			}

			void set(RawFunctionPointer cb, void* user)
			{
				_rawCallback = cb;
				_user = user;

				_callback = std::function<void(const T&)>();
			}

			void clear()
			{
				_rawCallback = nullptr;
				_user = nullptr;

				_callback = std::function<void(const T&)>();
			}

			bool valid() const
			{
				if (_rawCallback)
				{
					return true;
				}

				if (_callback)
				{
					return true;
				}

				return false;
			}

			uint32_t _id;
			RequestId _targetRequestId;
			uint32_t _status;
		private:
			RawFunctionPointer _rawCallback;
			void* _user;

			std::function<void(const T&)> _callback;
		};

		template<typename T, uint8_t IDMask>
		class CallbackCollection
		{
		public:
			CallbackCollection()
				: _currentHandle(0)
			{
			}

			~CallbackCollection()
			{
				for (uint32_t i = 0; i < _callbacks.size(); ++i)
				{
					delete _callbacks[i];
				}
			}

			typedef void (*RawFunctionPointer)(void*, const T&);

			bool validateId(uint32_t id)
			{
				// Check the ID byte for consistency.
				return ((id >> 24) & 0xFF) == IDMask;
			}

			uint32_t set(std::function<void(const T&)> fn, uint16_t requestId, uint32_t flags)
			{
				uint32_t id = nextID();
				Callback<T>* cb = new Callback<T>(id, requestId, flags);
				cb->set(fn);

				_lock.lock();
				_callbacks.push_back(cb);
				_lock.unlock();

				return id;
			}

			uint32_t set(RawFunctionPointer fn, void* user, uint16_t requestId, uint32_t flags)
			{
				uint32_t id = nextID();
				Callback<T>* cb = new Callback<T>(id, requestId, flags);
				cb->set(fn, user);

				_lock.lock();
				_callbacks.push_back(cb);
				_lock.unlock();

				return id;
			}

			void remove(uint32_t id)
			{
				_lock.lock();
				for (uint32_t i = 0; i < _callbacks.size(); ++i)
				{
					if (_callbacks[i]->_id == id)
					{
						_callbacks[i]->_status = CALLBACK_REMOVED;
					}
				}
				_lock.unlock();
			}

			// This must not be called recursively.
			void invoke(const T& v)
			{
				std::vector<Callback<T>*> copy;
				uint16_t requestId = v.meta.request_id;

				_lock.lock();
				copy = _callbacks;
				_lock.unlock();

				// Invoke the copied callbacks.
				for (uint32_t i = 0; i < copy.size(); ++i)
				{
					if (copy[i]->_targetRequestId == ANY_REQUEST_ID || copy[i]->_targetRequestId == requestId)
					{
						// Invoke if valid to do so.
						if (copy[i]->_status == CALLBACK_PERSISTENT || copy[i]->_status == CALLBACK_ONESHOT)
						{
							copy[i]->invoke(v);
						}

						if (copy[i]->_status == CALLBACK_ONESHOT)
						{
							copy[i]->_status = CALLBACK_REMOVED;
						}
					}
				}

				_lock.lock();
				auto it = std::remove_if(_callbacks.begin(), _callbacks.end(), [](const Callback<T>* cb) {
					if (cb->_status == CALLBACK_REMOVED)
					{
						delete cb;
						return true;
					}
					return false;
				});

				_callbacks.erase(it, _callbacks.end());
				_lock.unlock();
			}

		private:
			uint32_t nextID()
			{
				// Store a byte to determine if the id returned from a set operation belongs to this
				// collection of callbacks.
				static const uint32_t MASK = 0x0FFFFFFFu;
				uint32_t id = (_currentHandle & (MASK)) | (static_cast<uint32_t>(IDMask) << 24);
				_currentHandle = (_currentHandle + 1) & 0x0FFFFFFFu;
				return id;
			}

			uint32_t _currentHandle;
			gamelink::lock _lock;

			std::vector<Callback<T>*> _callbacks;
		};
	}


	/// The SDK class exposes functionality to interact with the Gamelink SDK.
	/// 
	/// @remark Most functions are thread safe, and can be called from multiple threads 
	///         concurrently, unless specifically denoted.
	class SDK
	{
	public:
		SDK();
		~SDK();

		// Not implemented. SDK is not copyable
		SDK(const SDK&);
		SDK& operator=(const SDK&);

		// Not implemented. SDK is not movable
		SDK(SDK&&);
		SDK& operator=(SDK&&);

		/// Receives a character buffer as a message. This function
		/// may invoke any callbacks that have been attached.
		/// @warning This function must only be called from one thread, and must not be 
		///          invoked recursively. This function will invoke any callbacks in the same 
		///          thread it is called in. Any arguments to any callbacks invoked by this
		///          function only live until the callback returns. This means that rescheduling
		///          a callback must copy any parameters.
		///
		/// @param[in] bytes Pointer to contiguous array of bytes that represent a network message.
		///                  This byte array must stay live until ReceiveMessage terminates.
		/// @param[in] length Length of the bytes array.
		/// @return Returns true if the message was parsed correctly.
		bool ReceiveMessage(const char* bytes, uint32_t length);

		/// Call this after a websocket reconnect after disconnect.
		/// This queues in an authorization message before any additional
		/// messages are sent.
		void HandleReconnect();

		/// Returns true if there are a non-zero amount of payloads to send.
		/// @remark This method is thread safe, but it is possible for 
		///         `if (HasPayloads()) { ForEachPayload(...) }` to execute
		///         the callback to ForEachPayload zero times.
		///
		/// @return returns if there are payloads to send.
		bool HasPayloads() const;

		/// Invokes a callable type for each avaliable payload.
		/// May invoke the callback zero times if there are no outstanding payloads.
		/// Does not internally sleep.
		///
		/// @param[in] networkCallback callback invoked once for each available payload.
		///                            must be in the form networkCallback(const Payload*)
		template<typename T>
		void ForeachPayload(const T& networkCallback)
		{
			while (true)
			{
				Payload* payload = NULL;
				_lock.lock();
				if (HasPayloadsNoLock())
				{
					payload = _queuedPayloads.front();
					_queuedPayloads.pop_front();
					_lock.unlock();
				}
				else
				{
					_lock.unlock();
					break;
				}

				if (payload)
				{
					if (payload->data.size() > 0)
					{
						networkCallback(payload);
					}
					delete payload;
				}
			}
		}

		/// Type used in ForeachPayload below. Takes in the user pointer as the first argument, 
		/// and a pointer to a payload as the second parameter.
		typedef void (*NetworkCallback)(void*, const Payload*);

		/// Invokes a function pointer for each avaliable payload.
		/// May invoke the callback zero times if there are no outstanding payloads.
		/// Does not internally sleep.
		///
		/// @param[in] cb Callback to be invoked for each avaliable payload
		/// @param[in] user User pointer that is passed into the callback
		void ForeachPayload(NetworkCallback cb, void* user);

		/// Returns if an authentication message has been received.
		///
		/// @return true if an authentication message has been received.
		bool IsAuthenticated() const;

		/// Gets the currently authenticated user. Will return NULL if !IsAuthenticated()
		///
		/// @return The currently authenticated user, or null if no authentication message
		///         has been recieved.
		const schema::User* GetUser() const;

		/// Gets the ClientID that was last passed into AuthenticateWithPIN or AuthenticateWithJWT
		///
		/// @return c-string representation of the input ClientID. This pointer is valid as long
		///         as the SDK object.
		const char* GetClientId() const;

		/// Sets the OnDebugMessage callback. This is invoked for debugging purposes only.
		/// There can only be one OnDebugMessage callback registered. Registering another
		/// callback will overwrite an existing one.
		///
		/// @param[in] callback Callback to log a debug message
		void OnDebugMessage(std::function<void(const string&)> callback);

		/// Sets the OnDebugMessage callback with a function pointer and user pointer.
		/// This is invoked for debugging purposes only.
		/// There can only be one OnDebugMessage callback registered. Registering another
		/// callback will overwrite an existing one.
		///
		/// @param[in] callback Callback to log a debug message.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		void OnDebugMessage(void (*callback)(void*, const string&), void* ptr);

		/// Detaches the OnDebugMessage callback, so no additional calls will be made.
		void DetachOnDebugMessage();

		/// Waits for a request to be responded to before sending further requests.
		/// @remark WaitForResponse is used to ensure a serializing of requests on the server.
		///			As an example, issuing back-to-back calls to DeletePoll, CreatePoll is 
		///         a common way to reset a poll. However, if DeletePoll happens after CreatePoll
		///         it can result in the newly created poll being immediately destroyed. 
		///         To prevent such reorderings, do id = DeletePoll(); WaitForResponse(id); CreatePoll()
		/// 
		/// @remark Waiting for the same request multiple times is a no-op.
		/// @warning Waiting for an invalid request id will result in no further messages sent. This 
		///          API does not check for request id validity.
		///
		/// @param[in] req A request id, as returned from an API call.
		void WaitForResponse(RequestId req);

		/// Sets the OnPollUpdate callback. This callback is invoked after SubscribeToPoll is called.
		/// @remark SubscribeToPoll takes in a poll id, but can be called multiple times with different poll ids.
		///        Callbacks registered through OnPollUpdate receive all update messages, regardless of poll id.
		///        Callbacks that are designed to only get updates for a specific poll id should test the poll id
		///        from within the callback itself.
		///
		/// @param[in] callback Callback to invoke when a poll update message is received
		/// @return Returns an integer handle to the callback, to be used in DetachOnPollUpdate.
		uint32_t OnPollUpdate(std::function<void(const schema::PollUpdateResponse&)> callback);

		/// Sets the OnPollUpdate callback. This callback is invoked after SubscribeToPoll is called.
		/// See the std::function overload for remarks.
		///
		/// @param[in] callback Callback to invoke when a poll update message is received
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnPollUpdate.
		uint32_t OnPollUpdate(void (*callback)(void*, const schema::PollUpdateResponse&), void* ptr);

		/// Detaches an OnPollUpdate callback.
		///
		/// @param[in] id A handle obtained from calling OnPollUpdate. Invalid handles are ignored.
		void DetachOnPollUpdate(uint32_t id);

		/// Sets the OnAuthenticate callback. This callback is invoked when an authentication
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when an authentication message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnAuthenticate.
		uint32_t OnAuthenticate(std::function<void(const schema::AuthenticateResponse&)> callback);

		/// Sets the OnAuthenticate callback. This callback is invoked when an authentication
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when an authentication message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnAuthenticate.
		uint32_t OnAuthenticate(void (*callback)(void*, const schema::AuthenticateResponse&), void* ptr);

		/// Detaches an OnAuthenticate callback.
		///
		/// @param[in] id A handle obtained from calling OnAuthenticate. Invalid handles are ignored.
		void DetachOnAuthenticate(uint32_t id);

		/// Sets the OnStateUpdate callback. This callback is invoked when a state update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a state update message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnStateUpdate.
		uint32_t OnStateUpdate(std::function<void(const schema::SubscribeStateUpdateResponse<nlohmann::json>&)> callback);

		/// Sets the OnStateUpdate callback. This callback is invoked when a state update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a state update message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnStateUpdate.
		uint32_t OnStateUpdate(void (*callback)(void*, const schema::SubscribeStateUpdateResponse<nlohmann::json>&), void* ptr);

		/// Detaches an OnStateUpdate callback.
		///
		/// @param[in] id A handle obtained from calling OnStateUpdate. Invalid handles are ignored.
		void DetachOnStateUpdate(uint32_t id);

		/// Starts subscribing to TwitchPurchaseBits updates for a specific SKU
		///
		/// @param[in] sku SKU of item to subscribe to
		/// @return RequestId of the generated request
		RequestId SubscribeToSKU(const string& sku);

		/// Unsubscribes from a specific SKU listened to by SubscribeToSKU
		///
		/// @param[in] sku SKU of item to unsubscribe to
		/// @return RequestId of the generated request
		RequestId UnsubscribeFromSKU(const string& sku);

		/// Subscribes to all SKUs.
		/// @return RequestId of the generated request
		RequestId SubscribeToAllPurchases();

		/// Unsubscribes from all SKUs.
		/// @return RequestId of the generated request
		RequestId UnsubscribeFromAllPurchases();

		/// Sets the OnTwitchPurchaseBits callback. This callback is invoked when twitch purchase
		/// message is received.
		/// @remarks The twitch purchase message has been authenticated and deduplicated by the server.
		///          This callback receives all SKUs purchased, so a callback for a specific SKU should
		///          test the SKU in the callback.
		///
		/// @param[in] callback Callback to invoke when a twitch purchase message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnTwitchPurchaseBits.
		uint32_t OnTwitchPurchaseBits(std::function<void(const schema::TwitchPurchaseBitsResponse<nlohmann::json>&)> callback);

		/// Sets the OnTwitchPurchaseBits callback. This callback is invoked when twitch purchase
		/// message is received.
		/// See the std::function overload for remarks.
		///
		/// @param[in] callback Callback to invoke when a twitch purchase message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnTwitchPurchaseBits.
		uint32_t OnTwitchPurchaseBits(void (*callback)(void*, const schema::TwitchPurchaseBitsResponse<nlohmann::json>&), void* ptr);

		/// Detaches an OnTwitchPurchaseBits callback.
		///
		/// @param[in] id A handle obtained from calling OnTwitchPurchaseBits. Invalid handles are ignored.
		void DetachOnTwitchPurchaseBits(uint32_t id);

		/// Queues an authentication request using a PIN code, as received by the user from an
		/// extension's config view.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] pin 		The PIN input from the broadcaster
		/// @return RequestId of the generated request
		RequestId AuthenticateWithPIN(const string& clientId, const string& pin);

		/// Queues an authentication request using a PIN code, as received by the user from an
		/// extension's config view.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] pin 		The PIN input from the broadcaster
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		/// @return RequestId of the generated request
		RequestId
		AuthenticateWithPIN(const string& clientId, const string& pin, std::function<void(const schema::AuthenticateResponse&)> callback);

		/// Queues an authentication request using a PIN code, as received by the user from an
		/// extension's config view.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] pin 		The PIN input from the broadcaster
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		/// @return RequestId of the generated request
		RequestId AuthenticateWithPIN(const string& clientId,
								 const string& pin,
								 void (*callback)(void*, const schema::AuthenticateResponse&),
								 void* user);

		/// Queues an authentication request using a JWT, as received after a successful PIN authentication request.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] jwt 		The stored JWT from a previous authentication
		/// @return RequestId of the generated request
		RequestId AuthenticateWithJWT(const string& clientId, const string& jwt);

		/// Queues an authentication request using a JWT, as received after a successful PIN authentication request.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] jwt 		The stored JWT from a previous authentication
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		/// @return RequestId of the generated request
		RequestId
		AuthenticateWithJWT(const string& clientId, const string& pin, std::function<void(const schema::AuthenticateResponse&)> callback);

		/// Queues an authentication request using a JWT, as received after a successful PIN authentication request.
		/// This overload attaches a one-shot callback to be called when the authentication response
		/// message is received.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] jwt 		The stored JWT from a previous authentication
		/// @param[in] callback Callback that is invoked once when this authentication request
		///                     is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		/// @return RequestId of the generated request
		RequestId AuthenticateWithJWT(const string& clientId,
								 const string& pin,
								 void (*callback)(void*, const schema::AuthenticateResponse&),
								 void* user);

		// Poll stuff, all async.

		/// Queues a request to get poll information, including results, for the poll with the given ID.
		/// Roughly equivilent to a single poll subscription update.
		/// Results are obtained through the OnPollUpdate callback.
		///
		/// @param[in] pollId The Poll ID to get information for
		/// @return RequestId of the generated request
		RequestId GetPoll(const string& pollId);

		/// Queues a request to get poll information. This overload attaches a one-shot callback to be
		/// called when poll information is received.
		///
		/// @param[in] pollId   The Poll ID to get information for
		/// @param[in] callback Callback invoked when this get poll request is responded to.
		/// @return RequestId of the generated request
		RequestId GetPoll(const string& pollId, std::function<void(const schema::GetPollResponse&)> callback);

		/// Queues a request to get poll information. This overload attaches a one-shot callback to be
		/// called when poll information is received.
		///
		/// @param[in] pollId   The Poll ID to get information for
		/// @param[in] callback Callback invoked when this get poll request is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		/// @return RequestId of the generated request
		RequestId GetPoll(const string& pollId, void (*callback)(void*, const schema::GetPollResponse&), void* user);

		/// Queues a request to create a poll.
		///
		/// @param[in] pollId The Poll ID to create
		/// @param[in] prompt The Prompt to store in the poll.
		/// @param[in] options An array of options to store in the poll.
		/// @return RequestId of the generated request
		RequestId CreatePoll(const string& pollId, const string& prompt, const std::vector<string>& options);

		/// Queues a request to create a poll.
		///
		/// @param[in] pollId The Poll ID to create
		/// @param[in] prompt The Prompt to store in the poll.
		/// @param[in] optionsBegin Pointer to the first element in an array of options to store in the poll.
		/// @param[in] optionsEnd Pointer one past the final entry in an array of options to store in the poll.
		/// @return RequestId of the generated request
		RequestId CreatePoll(const string& pollId, const string& prompt, const string* optionsBegin, const string* optionsEnd);

		/// Subscribes to updates for a given poll.
		/// Updates come through the OnPollUpdate callback.
		/// Once a poll stops receiving new votes, the subscription will stop receiving new updates.
		///
		/// @param[in] pollId The Poll ID to subscribe to
		/// @return RequestId of the generated request
		RequestId SubscribeToPoll(const string& pollId);

		/// Unsubscribes to updates for a given poll
		///
		/// @param[in] pollId The Poll ID to unsubscribe to
		/// @return RequestId of the generated request
		RequestId UnsubscribeFromPoll(const string& pollId);

		/// Deletes the poll with the given ID.
		///
		/// @param[in] pollId 	The ID of the poll to delete.
		/// @return RequestId of the generated request
		RequestId DeletePoll(const string& pollId);

		// State operations, all async.

		/// Queues a request to replace the entirety of state with new information.
		/// This will generate a StateUpdate subscription event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] value A serializable type. Will overwrite any existing state for the given target.
		///                  Cannot be an array or primitive type.
		/// @return RequestId of the generated request
		template<typename T>
		RequestId SetState(const char* target, const T& value)
		{
			nlohmann::json js = nlohmann::json(value);
			return SetState(target, js);
		};

		/// Queues a request to replace the entirety of state with new information.
		/// This will generate a StateUpdate subscription event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] value JSON. Will overwrite any existing state for the given target.
		///                  Must be an object, not an array or primitive type.
		/// @return RequestId of the generated request
		RequestId SetState(const char* target, const nlohmann::json& value);

		/// Queues a request to get state.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @return RequestId of the generated request
		RequestId GetState(const char* target);

		/// Queues a request to get state. This overload attaches a one-shot callback to be
		/// called when state is received.
		///
		/// @param[in] target   Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] callback Callback invoked when this state request is responded to.
		/// @return RequestId of the generated request
		RequestId GetState(const char* target, std::function<void(const schema::GetStateResponse<nlohmann::json>&)> callback);

		/// Queues a request to get state. This overload attaches a one-shot callback to be
		/// called when state is received.
		///
		/// @param[in] target   Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] callback Callback invoked when this state request is responded to.
		/// @param[in] user     User pointer that is passed into the callback whenever it is invoked.
		/// @return RequestId of the generated request
		RequestId GetState(const char* target, void (*callback)(void*, const schema::GetStateResponse<nlohmann::json>&), void* user);

		/// Queues a request to do a single JSON Patch operation on the state object.
		/// This will generate a StateUpdate event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] operation A JSON Patch operation
		/// @param[in] path A JSON Patch path.
		/// @param[in] atom The value to use in the patch operation
		/// @return RequestId of the generated request
		RequestId UpdateState(const char* target, const string& operation, const string& path, const schema::JsonAtom& atom);

		/// Queues a request to do many JSON Patch operations on the state object.
		/// This will generate a StateUpdate event.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] begin Pointer to the first element in an array of UpdateOperations
		/// @param[in] end Pointer one past the last element in an array of UpdateOperations
		/// @return RequestId of the generated request
		RequestId UpdateState(const char* target, const schema::PatchOperation* begin, const schema::PatchOperation* end);

		/// Starts subscribing to state updates for the given target.
		/// Updates come through the OnStateUpdate callback
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @return RequestId of the generated request
		RequestId SubscribeToStateUpdates(const char* target);

		/// Sends a broadcast to all viewers on the channel using the extension.
		/// @remark The serialized size of the value parameter must be under 8 kilobytes.
		///
		/// @param[in] topic The topic of the message to send. The frontend uses this value
		///                  to filter messages.
		/// @param[in] value Serializable, arbitrary object.
		/// @return RequestId of the generated request
		template<typename T>
		RequestId SendBroadcast(const string& topic, const T& value)
		{
			schema::BroadcastRequest<T> payload(topic, value);
			return queuePayload(payload);
		}

		/// Sends a broadcast to all viewers on the channel using the extension.
		/// @remark The serialized size of the message parameter must be under 8 kilobytes.
		///
		/// @param[in] topic The topic of the message to send. The frontend uses this value
		///                  to filter messages.
		/// @param[in] message Arbitrary json object. May not be a primitive or array.
		/// @return RequestId of the generated request
		RequestId SendBroadcast(const string& topic, const nlohmann::json& message);

		/// Sends a request to subscribe to the datastream.
		/// @return RequestId of the generated request
		RequestId SubscribeToDatastream();

		/// Sends a request to unsubscribe to the datastream.
		/// @return RequestId of the generated request
		RequestId UnsubscribeFromDatastream();

		/// Sets a OnDatastream callback. This callback is invoked when a datastream update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a datastream update message is received.
		/// @return Returns an integer handle to the callback, to be used in DetachOnDatastream.
		uint32_t OnDatastream(std::function<void(const schema::DatastreamUpdate&)> callback);

		/// Sets a OnDatastream callback. This callback is invoked when a datastream update
		/// message is received.
		///
		/// @param[in] callback Callback to invoke when a datastream update message is received.
		/// @param[in] ptr User pointer that is passed into the callback whenever it is invoked.
		/// @return Returns an integer handle to the callback, to be used in DetachOnDatastream.
		uint32_t OnDatastream(void (*callback)(void*, const schema::DatastreamUpdate&), void* user);

		/// Detaches an OnDatastream callback.
		///
		/// @param[in] id A handle obtained from calling OnDatastream. Invalid handles are ignored.
		void DetachOnDatastream(uint32_t);
	private:
		void debugLogPayload(const Payload*);

		bool HasPayloadsNoLock() const;

		template<typename T>
		RequestId queuePayload(T& p)
		{
			RequestId id = nextRequestId();
			p.params.request_id = id;

			Payload* payload = new Payload(gamelink::string(to_string(p).c_str()));

			debugLogPayload(payload);

			_lock.lock();
			_queuedPayloads.push_back(payload);
			_lock.unlock();

			return id;
		}

		// Fields stored to handle reconnects
		gamelink::string _storedJWT;
		gamelink::string _storedClientId;

		mutable gamelink::lock _lock;

		std::deque<Payload*> _queuedPayloads;
		schema::User* _user;

		RequestId _currentRequestId;
		RequestId nextRequestId();

		void addToBarrier(uint16_t);
		void removeFromBarrier(uint16_t);

		detail::Callback<string> _onDebugMessage;

		detail::CallbackCollection<schema::PollUpdateResponse, 1> _onPollUpdate;
		detail::CallbackCollection<schema::AuthenticateResponse, 2> _onAuthenticate;
		detail::CallbackCollection<schema::SubscribeStateUpdateResponse<nlohmann::json>, 3> _onStateUpdate;
		detail::CallbackCollection<schema::GetStateResponse<nlohmann::json>, 4> _onGetState;
		detail::CallbackCollection<schema::TwitchPurchaseBitsResponse<nlohmann::json>, 5> _onTwitchPurchaseBits;
		detail::CallbackCollection<schema::GetPollResponse, 6> _onGetPoll;
		detail::CallbackCollection<schema::DatastreamUpdate, 7> _onDatastreamUpdate;
	};
}

#endif

#endif
#ifdef MUXY_GAMELINK_SINGLE_IMPL


namespace gamelink
{
	namespace schema
	{
		SubscribeAuthenticationRequest::SubscribeAuthenticationRequest()
		{
			action = string("subscribe");
			params.target = string("authentication");
		}

		AuthenticateWithPINRequest::AuthenticateWithPINRequest(const string& client, const string& pin)
		{
			action = string("authenticate");
			params.target = string("");
			data.pin = pin;
			data.client_id = client;
		}

		AuthenticateWithJWTRequest::AuthenticateWithJWTRequest(const string& client, const string& jwt)
		{
			action = string("authenticate");
			params.target = string("");
			data.jwt = jwt;
			data.client_id = client;
		}

		User::User(string jwt)
			: jwt(std::move(jwt))
		{
		}

		const string& User::GetJWT() const
		{
			return this->jwt;
		}
	}
}




namespace gamelink
{
	namespace schema
	{
		SubscribeDatastreamRequest::SubscribeDatastreamRequest()
		{
			action = string("subscribe");
			params.target = string("datastream");
		}

		UnsubscribeDatastreamRequest::UnsubscribeDatastreamRequest()
		{
			action = string("unsubscribe");
			params.target = string("datastream");
		}
	}
}



namespace gamelink
{
	namespace schema
	{
		JsonAtom atomFromInteger(int64_t v)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_INT64;
			atom.int64Value = v;

			return atom;
		}

		JsonAtom atomFromDouble(double v)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_DOUBLE;
			atom.doubleValue = v;

			return atom;
		}

		JsonAtom atomFromString(const string& str)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_STRING;
			atom.stringValue = str;

			return atom;
		}

		JsonAtom atomFromLiteral(const string& str)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_LITERAL;
			atom.stringValue = str;

			return atom;
		}

		JsonAtom atomNull()
		{
			JsonAtom atom;
			atom.type = JSON_ATOM_NULL;
			return atom;
		}

		void to_json(nlohmann::json& out, const JsonAtom& p)
		{
			switch (p.type)
			{
			case JSON_ATOM_NULL:
				out = nlohmann::json();
				break;
			case JSON_ATOM_INT64:
				out = p.int64Value;
				break;
			case JSON_ATOM_DOUBLE:
				out = p.doubleValue;
				break;
			case JSON_ATOM_STRING:
				out = p.stringValue;
				break;
			case JSON_ATOM_LITERAL:
				out = nlohmann::json::parse(p.stringValue.c_str(), nullptr, false);
				break;
			default:
				// Bad
				out = nlohmann::json();
				break;
			}
		}

		void from_json(const nlohmann::json& n, JsonAtom& p)
		{
			p.type = JSON_ATOM_NULL;
			if (n.is_null())
			{
				p.type = JSON_ATOM_NULL;
				return;
			}
			else if (n.is_string())
			{
				p.type = JSON_ATOM_STRING;
				p.stringValue = n.get<string>();
				return;
			}
			else if (n.is_number_integer())
			{
				p.type = JSON_ATOM_INT64;
				p.int64Value = n.get<int64_t>();
				return;
			}
			else if (n.is_number())
			{
				p.type = JSON_ATOM_DOUBLE;
				p.doubleValue = n.get<double>();
			}
			else if (n.is_object() || n.is_array())
			{
				p.type = JSON_ATOM_LITERAL;
				p.stringValue = gamelink::string(n.dump().c_str());
			}
		}

		ReceiveMeta::ReceiveMeta()
			: request_id(0)
			, timestamp(0)
		{
		}

		SendParameters::SendParameters()
			: request_id(0xFFFF)
		{
		}

		ReceiveEnvelope<EmptyBody> ParseEnvelope(const char* bytes, uint32_t length, bool* outSuccess)
		{
			ReceiveEnvelope<EmptyBody> out;
			bool result = ParseResponse(bytes, length, out);
			if (outSuccess)
			{
				*outSuccess = result;
			}
			return out;
		}
	}
}



namespace gamelink
{
	namespace schema
	{
		GetPollRequest::GetPollRequest(const string& pollId)
		{
			action = string("get");
			params.target = string("poll");

			data.pollId = pollId;
		}

		DeletePollRequest::DeletePollRequest(const string& pollId)
		{
			action = string("delete");
			params.target = string("poll");

			data.pollId = pollId;
		}

		CreatePollRequest::CreatePollRequest(const string& pollId, const string& prompt, const std::vector<string>& options)
		{
			action = string("create");
			params.target = string("poll");

			data.pollId = pollId;
			data.prompt = prompt;
			data.options = options;
		}

		SubscribePollRequest::SubscribePollRequest(const string& pollId)
		{
			action = string("subscribe");
			params.target = string("poll");
			data.topic_id = string(pollId);
		}

		UnsubscribePollRequest::UnsubscribePollRequest(const string& pollId)
		{
			action = string("unsubscribe");
			params.target = string("poll");
			data.topic_id = string(pollId);
		}
	}
}



namespace gamelink
{
    namespace schema
    {
        SubscribeTransactionsRequest::SubscribeTransactionsRequest(const string& SKU)
        {
            action = string("subscribe");
            params.target = string("twitchPurchaseBits");
            data.sku = SKU;
        }

        UnsubscribeTransactionsRequest::UnsubscribeTransactionsRequest(const string& SKU)
        {
            action = string("unsubscribe");
            params.target = string("twitchPurchaseBits");
            data.sku = SKU;
        }
    }
}



namespace gamelink
{
	namespace schema
	{
		GetStateRequest::GetStateRequest(const char* target)
		{
			action = string("get");
			params.target = string("state");
			data.state_id = string(target);
		}

		PatchStateRequest::PatchStateRequest(const char* target)
		{
			action = string("patch");
			params.target = string("state");
			data.state_id = string(target);
		}

		SubscribeStateRequest::SubscribeStateRequest(const char* target)
		{
			action = string("subscribe");
			params.target = string("state");
			data.topic_id = string(target);
		}
	}
}

#include <cstdio>
#include <iostream>

namespace gamelink
{
	Payload::Payload(string data)
		:waitingForResponse(ANY_REQUEST_ID)
		,data(data)
	{}

	SDK::SDK()
		: _user(NULL)
		, _currentRequestId(1)
		, _onDebugMessage(0, 0, detail::CALLBACK_PERSISTENT){};

	SDK::~SDK()
	{
		// Clean up unsent messages
		for (uint32_t i = 0; i < _queuedPayloads.size(); ++i)
		{
			delete _queuedPayloads[i];
		}
	}

	RequestId SDK::nextRequestId()
	{
		// Wrap around at 32k
		RequestId id = (_currentRequestId++ & 0x7F);
		return id;
	}

	void SDK::debugLogPayload(const Payload* s)
	{
		if (_onDebugMessage.valid())
		{
			uint32_t bufferLength = s->data.size() + 128;
			char* buffer = new char[bufferLength];

			int offset = snprintf(buffer, bufferLength, "send len=%d msg=", static_cast<int>(s->data.size()));
			memcpy(buffer + offset, s->data.c_str(), s->data.size());
			buffer[s->data.size() + offset] = '\0';

			_onDebugMessage.invoke(string(buffer));

			delete[] buffer;
		}
	}

	bool SDK::HasPayloads() const
	{
		_lock.lock();
		bool result = HasPayloadsNoLock();
		_lock.unlock();
		
		return result;
	}

	bool SDK::HasPayloadsNoLock() const
	{
		if (_queuedPayloads.size() > 0) 
		{
			if (_queuedPayloads.front()->waitingForResponse != ANY_REQUEST_ID)
			{
				return false;
			}

			return true;
		}

		return false;
	}

	void SDK::ForeachPayload(SDK::NetworkCallback networkCallback, void* user)
	{
		while (true)
		{
			Payload* payload = NULL;
			_lock.lock();
			if (HasPayloadsNoLock())
			{
				payload = _queuedPayloads.front();
				_queuedPayloads.pop_front();
				_lock.unlock();
			}
			else
			{
				_lock.unlock();
				break;
			}

			if (payload)
			{
				if (payload->data.size() > 0)
				{
					networkCallback(user, payload);
				}

				delete payload;
			}
		}
	}

	bool SDK::ReceiveMessage(const char* bytes, uint32_t length)
	{
		bool success = false;
		bool parseEnvelopeSuccess = false;
		schema::ReceiveEnvelope<schema::EmptyBody> env = schema::ParseEnvelope(bytes, length, &parseEnvelopeSuccess);
		if (!parseEnvelopeSuccess)
		{
			return false;
		}

		_lock.lock();
		// Set any waits for the id just received to any_request_id
		for (uint32_t i = 0; i < _queuedPayloads.size(); ++i)
		{
			if (_queuedPayloads[i]->waitingForResponse == env.meta.request_id && env.meta.request_id != ANY_REQUEST_ID)
			{
				_queuedPayloads[i]->waitingForResponse = ANY_REQUEST_ID;
			}
		}

		// Clear any waits at the front of the queue.
		while (_queuedPayloads.size() > 0)
		{
			Payload * p = _queuedPayloads.front();
			if (p->waitingForResponse == ANY_REQUEST_ID && p->data.size() == 0)
			{
				_queuedPayloads.pop_front();
				delete p;
			}
			else
			{
				break;
			}
		}
		_lock.unlock();

		if (_onDebugMessage.valid())
		{
			uint32_t bufferLength = length + 128;
			char* buffer = new char[bufferLength];

			int offset = snprintf(buffer, bufferLength, "recv len=%d msg=", static_cast<int>(length));
			memcpy(buffer + offset, bytes, length);
			buffer[length + offset] = '\0';

			_onDebugMessage.invoke(string(buffer));

			delete[] buffer;
		}

		if (env.meta.action == "authenticate")
		{
			// Authentication response
			schema::AuthenticateResponse authResp;
			success = schema::ParseResponse(bytes, length, authResp);
			if (success)
			{
				_user = new schema::User(authResp.data.jwt);
				_storedJWT = authResp.data.jwt;

				_onAuthenticate.invoke(authResp);
			}
		}
		else if (env.meta.action == "get")
		{
			if (env.meta.target == "state")
			{
				schema::GetStateResponse<nlohmann::json> stateResp;
				success = schema::ParseResponse(bytes, length, stateResp);

				if (success)
				{
					_onGetState.invoke(stateResp);
				}
			}

			if (env.meta.target == "poll")
			{
				schema::GetPollResponse pollResp;
				success = schema::ParseResponse(bytes, length, pollResp);

				if (success)
				{
					_onGetPoll.invoke(pollResp);
				}
			}
		}
		else if (env.meta.action == "update")
		{
			if (env.meta.target == "poll")
			{
				// Poll update response
				// TODO Handle a UserDataPollUpdateResponse as well
				schema::PollUpdateResponse pollResp;
				success = schema::ParseResponse<schema::PollUpdateResponse>(bytes, length, pollResp);
				if (success)
				{
					_onPollUpdate.invoke(pollResp);
				}
			}
			else if (env.meta.target == "channel")
			{
				schema::SubscribeStateUpdateResponse<nlohmann::json> resp;

				success = schema::ParseResponse(bytes, length, resp);
				if (success)
				{
					_onStateUpdate.invoke(resp);
				}
			}
			else if (env.meta.target == "twitchPurchaseBits")
			{
				schema::TwitchPurchaseBitsResponse<nlohmann::json> resp;
				success = schema::ParseResponse(bytes, length, resp);
				if (success)
				{
					_onTwitchPurchaseBits.invoke(resp);
				}
			}
			else if (env.meta.target == "datastream")
			{
				schema::DatastreamUpdate resp;
				success = schema::ParseResponse(bytes, length, resp);
				if (success)
				{
					_onDatastreamUpdate.invoke(resp);
				}
			}
		}

		return success;
	}

	bool SDK::IsAuthenticated() const
	{
		return _user != NULL;
	}

	const schema::User* SDK::GetUser() const
	{
		return _user;
	}

	const char* SDK::GetClientId() const
	{
		return _storedClientId.c_str();
	}

	void SDK::HandleReconnect()
	{
		if (!(_storedJWT == gamelink::string("")))
		{
			schema::AuthenticateWithJWTRequest p(_storedClientId, _storedJWT);
			Payload* payload = new Payload(gamelink::string(to_string(p).c_str()));
			debugLogPayload(payload);

			_lock.lock();
			_queuedPayloads.push_front(payload);
			_lock.unlock();
		}
	}

	// Callbacks
	void SDK::OnDebugMessage(std::function<void(const string&)> callback)
	{
		_onDebugMessage.set(callback);
	}

	void SDK::OnDebugMessage(void (*callback)(void*, const string&), void* ptr)
	{
		_onDebugMessage.set(callback, ptr);
	}

	void SDK::DetachOnDebugMessage()
	{
		_onDebugMessage.clear();
	}

	void SDK::WaitForResponse(RequestId req)
	{
		Payload* wait = new Payload("");
		wait->waitingForResponse = req;

		_lock.lock();
		_queuedPayloads.push_back(wait);
		_lock.unlock();
	}

	RequestId SDK::SendBroadcast(const string& topic, const nlohmann::json& msg)
	{
		schema::BroadcastRequest<nlohmann::json> payload(topic, msg);
		return queuePayload(payload);
	}
}



namespace gamelink
{
    uint32_t SDK::OnAuthenticate(std::function<void(const schema::AuthenticateResponse&)> callback)
	{
		return _onAuthenticate.set(callback, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnAuthenticate(void (*callback)(void*, const schema::AuthenticateResponse&), void* ptr)
	{
		return _onAuthenticate.set(callback, ptr, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnAuthenticate(uint32_t id)
	{
		if (_onAuthenticate.validateId(id))
		{
			_onAuthenticate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnAuthenticate");
		}
	}

    
	RequestId SDK::AuthenticateWithPIN(const string& clientId, const string& pin)
	{
		schema::AuthenticateWithPINRequest payload(clientId, pin);
		_storedClientId = clientId;

		return queuePayload(payload);
	}

	RequestId
	SDK::AuthenticateWithPIN(const string& clientId, const string& pin, std::function<void(const schema::AuthenticateResponse&)> callback)
	{
		schema::AuthenticateWithPINRequest payload(clientId, pin);
		_storedClientId = clientId;

		RequestId id = queuePayload(payload);
		_onAuthenticate.set(callback, id, detail::CALLBACK_ONESHOT);
		return id;
	}

	RequestId SDK::AuthenticateWithPIN(const string& clientId,
								  const string& pin,
								  void (*callback)(void*, const schema::AuthenticateResponse&),
								  void* user)
	{
		schema::AuthenticateWithPINRequest payload(clientId, pin);
		_storedClientId = clientId;

		RequestId id = queuePayload(payload);
		_onAuthenticate.set(callback, user, id, detail::CALLBACK_ONESHOT);
		return id;
	}

	RequestId SDK::AuthenticateWithJWT(const string& clientId, const string& jwt)
	{
		schema::AuthenticateWithJWTRequest payload(clientId, jwt);
		_storedClientId = clientId;

		return queuePayload(payload);
	}

	RequestId
	SDK::AuthenticateWithJWT(const string& clientId, const string& jwt, std::function<void(const schema::AuthenticateResponse&)> callback)
	{
		schema::AuthenticateWithJWTRequest payload(clientId, jwt);
		_storedClientId = clientId;

		RequestId id = queuePayload(payload);
		_onAuthenticate.set(callback, id, detail::CALLBACK_ONESHOT);
		return id;
	}

	RequestId SDK::AuthenticateWithJWT(const string& clientId,
								  const string& jwt,
								  void (*callback)(void*, const schema::AuthenticateResponse&),
								  void* user)
	{
		schema::AuthenticateWithJWTRequest payload(clientId, jwt);
		_storedClientId = clientId;

		RequestId id = queuePayload(payload);
		_onAuthenticate.set(callback, user, id, detail::CALLBACK_ONESHOT);
		return id;
	}
}


namespace gamelink
{
	RequestId SDK::SubscribeToDatastream()
	{
		schema::SubscribeDatastreamRequest payload;
		return queuePayload(payload);
	}

	RequestId SDK::UnsubscribeFromDatastream()
	{
		schema::UnsubscribeDatastreamRequest payload;
		return queuePayload(payload);
	}

	uint32_t SDK::OnDatastream(std::function<void(const schema::DatastreamUpdate&)> callback)
	{
		return _onDatastreamUpdate.set(callback, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnDatastream(void (*callback)(void*, const schema::DatastreamUpdate&), void* user)
	{
		return _onDatastreamUpdate.set(callback, user, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnDatastream(uint32_t id)
	{
		if (_onDatastreamUpdate.validateId(id))
		{
			_onDatastreamUpdate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnDatastream");
		}
	}
}


namespace gamelink
{
    uint32_t SDK::OnPollUpdate(std::function<void(const schema::PollUpdateResponse& pollResponse)> callback)
	{
		return _onPollUpdate.set(callback, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnPollUpdate(void (*callback)(void*, const schema::PollUpdateResponse&), void* ptr)
	{
		return _onPollUpdate.set(callback, ptr, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnPollUpdate(uint32_t id)
	{
		if (_onPollUpdate.validateId(id))
		{
			_onPollUpdate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnPollUpdate");
		}
	}

	RequestId SDK::GetPoll(const string& pollId)
	{
		schema::GetPollRequest packet(pollId);
		return queuePayload(packet);
	}

	RequestId SDK::GetPoll(const string& pollId, std::function<void(const schema::GetPollResponse&)> callback)
	{
		schema::GetPollRequest payload(pollId);
		
		RequestId id = queuePayload(payload);
		_onGetPoll.set(callback, id, detail::CALLBACK_ONESHOT);
		return id;
	}

	RequestId SDK::GetPoll(const string& pollId, void (*callback)(void*, const schema::GetPollResponse&), void* user)
	{
		schema::GetPollRequest payload(pollId);

		RequestId id = queuePayload(payload);
		_onGetPoll.set(callback, user, id, detail::CALLBACK_ONESHOT);
		return id;
	}

	RequestId SDK::CreatePoll(const string& pollId, const string& prompt, const std::vector<string>& options)
	{
		schema::CreatePollRequest packet(pollId, prompt, options);
		return queuePayload(packet);
	}

	RequestId SDK::UnsubscribeFromPoll(const string& pollId)
	{
		schema::UnsubscribePollRequest packet(pollId);
		return queuePayload(packet);
	}

	RequestId SDK::SubscribeToPoll(const string& pollId)
	{
		schema::SubscribePollRequest packet(pollId);
		return queuePayload(packet);
	}

	RequestId SDK::DeletePoll(const string& pollId)
	{
		schema::DeletePollRequest payload(pollId);
		return queuePayload(payload);
	}
}


namespace gamelink
{
	RequestId SDK::SubscribeToSKU(const string& sku)
	{
		schema::SubscribeTransactionsRequest payload(sku);
		return queuePayload(payload);
	}

	RequestId SDK::SubscribeToAllPurchases()
	{
		return SubscribeToSKU("*");
	}

	RequestId SDK::UnsubscribeFromSKU(const string& sku)
	{
		schema::UnsubscribeTransactionsRequest payload(sku);
		return queuePayload(payload);
	}

	RequestId SDK::UnsubscribeFromAllPurchases()
	{
		return UnsubscribeFromSKU("*");
	}

	uint32_t SDK::OnTwitchPurchaseBits(std::function<void(const schema::TwitchPurchaseBitsResponse<nlohmann::json>&)> callback)
	{
		return _onTwitchPurchaseBits.set(callback, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnTwitchPurchaseBits(void (*callback)(void*, const schema::TwitchPurchaseBitsResponse<nlohmann::json>&), void* ptr)
	{
		return _onTwitchPurchaseBits.set(callback, ptr, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnTwitchPurchaseBits(uint32_t id)
	{
		if (_onTwitchPurchaseBits.validateId(id))
		{
			_onTwitchPurchaseBits.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into DetachOnTwitchPurchaseBits");
		}
	}
}


namespace gamelink
{
	uint32_t SDK::OnStateUpdate(std::function<void(const schema::SubscribeStateUpdateResponse<nlohmann::json>&)> callback)
	{
		return _onStateUpdate.set(callback, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	uint32_t SDK::OnStateUpdate(void (*callback)(void*, const schema::SubscribeStateUpdateResponse<nlohmann::json>&), void* ptr)
	{
		return _onStateUpdate.set(callback, ptr, ANY_REQUEST_ID, detail::CALLBACK_PERSISTENT);
	}

	void SDK::DetachOnStateUpdate(uint32_t id)
	{
		if (_onStateUpdate.validateId(id))
		{
			_onStateUpdate.remove(id);
		}
		else
		{
			_onDebugMessage.invoke("Invalid ID passed into OnStateUpdate");
		}
	}

	RequestId SDK::SetState(const char* target, const nlohmann::json& value)
	{
		schema::SetStateRequest<nlohmann::json> payload(target, value);
		return queuePayload(payload);
	}

	RequestId SDK::GetState(const char* target)
	{
		schema::GetStateRequest payload(target);
		return queuePayload(payload);
	}

	RequestId SDK::GetState(const char* target, std::function<void(const schema::GetStateResponse<nlohmann::json>&)> callback)
	{
		schema::GetStateRequest payload(target);
		RequestId id = queuePayload(payload);
		_onGetState.set(callback, id, detail::CALLBACK_ONESHOT);
		return id;
	}

	RequestId SDK::GetState(const char* target, void (*callback)(void*, const schema::GetStateResponse<nlohmann::json>&), void* user)
	{
		schema::GetStateRequest payload(target);

		RequestId id = queuePayload(payload);
		_onGetState.set(callback, user, id, detail::CALLBACK_ONESHOT);
		return id;
	}

	RequestId SDK::SubscribeToStateUpdates(const char* target)
	{
		schema::SubscribeStateRequest payload(target);
		return queuePayload(payload);
	}

	RequestId SDK::UpdateState(const char* target, const string& operation, const string& path, const schema::JsonAtom& atom)
	{
		schema::PatchOperation op;
		op.operation = operation;
		op.path = path;
		op.value = atom;

		return UpdateState(target, &op, &op + 1);
	}

	RequestId SDK::UpdateState(const char* target, const schema::PatchOperation* begin, const schema::PatchOperation* end)
	{
		schema::PatchStateRequest payload(target);
		std::vector<schema::PatchOperation> updates;
		updates.resize(end - begin);
		std::copy(begin, end, updates.begin());

		payload.data.state = std::move(updates);
		return queuePayload(payload);
	};
}
#endif
