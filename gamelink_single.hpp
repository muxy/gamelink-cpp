/* This file is automatically generated from multiple sources. Do not modify */


#ifndef MUXY_GAMELINK_SINGLE_HPP
#define MUXY_GAMELINK_SINGLE_HPP
#pragma once

#ifndef MUXY_GAMELINK_CONFIG_H
#define MUXY_GAMELINK_CONFIG_H

// Support custom string types.
#ifndef MUXY_GAMELINK_CUSTOM_STRING_TYPE
#include <string>
#define MUXY_GAMELINK_CUSTOM_STRING_TYPE std::string
#endif

#ifndef NO_JSON_INCLUDE
#include <nlohmann/json.hpp>
#endif

namespace gamelink
{
	/// This can be controlled by defining `MUXY_GAMELINK_CUSTOM_STRING_TYPE`.
	/// By default, MUXY_GAMELINK_CUSTOM_STRING_TYPE is std::string
	/// This string should
	///     * Provide a constructor from a null-terminated c-string of chars
	///     * Provide operator== with another instance of the string type.
	///     * Provide a c_str() that returns a pointer to the first element of a
	///       null-terminated array of utf8 encoded chars.
	typedef MUXY_GAMELINK_CUSTOM_STRING_TYPE string;
}

#endif



#ifndef MUXY_GAMELINK_SCHEMA_SERIALIZATION_H
#define MUXY_GAMELINK_SCHEMA_SERIALIZATION_H

#define MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, name, out, property) \
	{ nlohmann::json::const_iterator it = in.find(name); if (it != in.end()) { it->get_to(out. property); }}


#define MUXY_GAMELINK_SERIALIZE_0(Type) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_0(Type) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
	}

#define MUXY_GAMELINK_SERIALIZE_1(Type, n1, p1) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(Type, n1, p1) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
	}

#define MUXY_GAMELINK_SERIALIZE_2(Type, n1, p1, n2, p2) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(Type, n1, p1, n2, p2) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
	}

#define MUXY_GAMELINK_SERIALIZE_3(Type, n1, p1, n2, p2, n3, p3) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(Type, n1, p1, n2, p2, n3, p3) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
	}

#define MUXY_GAMELINK_SERIALIZE_4(Type, n1, p1, n2, p2, n3, p3, n4, p4) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_4(Type, n1, p1, n2, p2, n3, p3, n4, p4) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
	}

#define MUXY_GAMELINK_SERIALIZE_5(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_5(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
	}

#define MUXY_GAMELINK_SERIALIZE_6(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_6(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
	}

#define MUXY_GAMELINK_SERIALIZE_7(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_7(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
	}

#define MUXY_GAMELINK_SERIALIZE_8(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
		out[n8] = p. p8; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_8(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
		out[n8] = p. p8; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8) \
	}

#define MUXY_GAMELINK_SERIALIZE_9(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
		out[n8] = p. p8; \
		out[n9] = p. p9; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_9(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
		out[n8] = p. p8; \
		out[n9] = p. p9; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9) \
	}

#define MUXY_GAMELINK_SERIALIZE_10(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9, n10, p10) \
    inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
		out[n8] = p. p8; \
		out[n9] = p. p9; \
		out[n10] = p. p10; \
	} \
    inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n10, p, p10) \
	}

#define MUXY_GAMELINK_SERIALIZE_INTRUSIVE_10(Type, n1, p1, n2, p2, n3, p3, n4, p4, n5, p5, n6, p6, n7, p7, n8, p8, n9, p9, n10, p10) \
    friend inline void to_json(nlohmann::json& out, const Type& p) {      \
		out[n1] = p. p1; \
		out[n2] = p. p2; \
		out[n3] = p. p3; \
		out[n4] = p. p4; \
		out[n5] = p. p5; \
		out[n6] = p. p6; \
		out[n7] = p. p7; \
		out[n8] = p. p8; \
		out[n9] = p. p9; \
		out[n10] = p. p10; \
	} \
    friend inline void from_json(const nlohmann::json& in, Type& p) {     \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n1, p, p1) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n2, p, p2) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n3, p, p3) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n4, p, p4) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n5, p, p5) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n6, p, p6) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n7, p, p7) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n8, p, p8) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n9, p, p9) \
		MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, n10, p, p10) \
	}


#endif


#ifndef MUXY_GAMELINK_SCHEMA_ENVELOPE_H
#define MUXY_GAMELINK_SCHEMA_ENVELOPE_H



namespace gamelink
{
	namespace schema
	{
		// A JSON atom reprsents one of the 4 supported base types of json value -
		// An integer, double, string, null
		enum JsonAtomType
		{
			JSON_ATOM_NULL,   //!< No fields are valid, the JSONAtom represents a null
			JSON_ATOM_INT64,  //!< The int64Value field is valid, and the JSONAtom represents an integer.
			JSON_ATOM_DOUBLE, //!< The doubleValue field is valid, and the JSONAtom represents a double.
			JSON_ATOM_STRING, //!< The stringValue field is valid, and the JSONAtom represents a string.

			JSON_ATOM_FORCE_32 = 0xFFFFFFFF
		};

		/// JSONAtom is effectively a tagged union that can contain a signed 64-bit integer,
		/// a floating point double, a string, or null. The type of a JSONAtom is stored in
		/// the `field` type.
		struct JsonAtom
		{
			/// Type of the contained value
			JsonAtomType type;

			/// Integer value
			int64_t int64Value;

			/// Double value
			double doubleValue;

			/// String value
			string stringValue;
		};

		/// Creates a JsonAtom that represents an integer
		/// @param[in] v Integer value
		/// @return JsonAtom that contains the input integer value
		JsonAtom atomFromInteger(int64_t v);

		/// Creates a JsonAtom that represents a double
		/// @param[in] d Double value
		/// @return JsonAtom that contains the input double value
		JsonAtom atomFromDouble(double d);

		/// Creates a JsonAtom that represents a string
		/// @param[in] str String value
		/// @return JsonAtom that contains the input string value
		JsonAtom atomFromString(const string& str);

		/// Creates a JsonAtom that represents null
		/// @return A null JsonAtom
		JsonAtom atomNull();

		void to_json(nlohmann::json& out, const JsonAtom& p);
		void from_json(const nlohmann::json& in, JsonAtom& p);

		/// Contains metadata fields about a response
		struct ReceiveMeta
		{
			ReceiveMeta();

			/// Request ID, as sent by the response
			uint16_t request_id;

			/// Action of the request
			string action;

			/// Target of the request
			string target;

			/// Unix timestamp in milliseconds since epoch.
			uint64_t timestamp;
		};

		MUXY_GAMELINK_SERIALIZE_4(ReceiveMeta, "request_id", request_id, "action", action, "target", target, "timestamp", timestamp)

		/// Error type, possibly returned by any API call.
		struct Error
		{
			/// Unsigned error code. Correlates to HTTP error codes.
			uint32_t number;

			/// Human readable error title.
			string title;

			/// Human readable detail field.
			string detail;
		};

		MUXY_GAMELINK_SERIALIZE_3(Error, "number", number, "title", title, "detail", detail)

		/// ReceiveEnvelope
		template<typename T>
		struct ReceiveEnvelope
		{
			/// Metadata about this response
			ReceiveMeta meta;

			/// Data field. Will vary based on the response.
			/// See the type documentation for more details.
			T data;

			/// Errors list. Mutually exclusive with data.
			/// May contain more than one error.
			std::vector<Error> errors;
		};

		template<typename T>
		void to_json(nlohmann::json& out, const ReceiveEnvelope<T>& p)
		{
			out["meta"] = p.meta;
			out["data"] = p.data;

			if (p.errors.size())
			{
				out["errors"] = p.errors;
			}
		}

		template<typename T>
		void from_json(const nlohmann::json& in, ReceiveEnvelope<T>& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "meta", p, meta);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "data", p, data);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "errors", p, errors);
		}

		struct SendParameters
		{
			SendParameters();

			/// Request ID. Will be echoed back in the response.
			/// By default, is 0xFFFF
			uint16_t request_id;

			/// Target field. Will vary in behavior based on action.
			string target;
		};

		inline void to_json(nlohmann::json& out, const SendParameters& p)
		{
			out["request_id"] = p.request_id;
			if (p.target.size())
			{
				out["target"] = p.target;
			}
		}

		inline void from_json(const nlohmann::json& in, SendParameters& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "request_id", p, request_id);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "target", p, target);
		}

		template<typename T>
		struct SendEnvelope
		{
			/// The action of this request.
			string action;

			/// Parameters of this request.
			SendParameters params;

			/// Data field. Will vary based on the response.
			/// See the type documentation for more details.
			T data;
		};

		template<typename T>
		void to_json(nlohmann::json& out, const SendEnvelope<T>& p)
		{
			out["action"] = p.action;
			out["params"] = p.params;
			out["data"] = p.data;
		}

		template<typename T>
		void from_json(const nlohmann::json& in, SendEnvelope<T>& p)
		{
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "action", p, action);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "params", p, params);
			MUXY_GAMELINK_DESERIALIZE_PROPERTY(in, "data", p, data);
		}

		template<typename T>
		std::string to_string(const SendEnvelope<T>& p)
		{
			nlohmann::json out;
			to_json(out, p);
			return out.dump();
		}

		/// The empty body. Has no members.
		struct EmptyBody
		{
		};

		/// OKResponseBody is sent back when a simple operation succeeds.
		struct OKResponseBody
		{
			/// Will always be 'true'. If an error occurred, then
			/// the errors array in the response would be set.
			bool ok;
		};

		MUXY_GAMELINK_SERIALIZE_1(OKResponseBody, "ok", ok)

		// Specialization for empty body serialization
		MUXY_GAMELINK_SERIALIZE_2(SendEnvelope<EmptyBody>, "action", action, "params", params);
		MUXY_GAMELINK_SERIALIZE_2(ReceiveEnvelope<EmptyBody>, "meta", meta, "errors", errors);

		/// Parse a response object
		/// @param[in] bytes JSON input bytes. Must not be null.
		/// @param[in] length Length of the bytes parameter
		/// @param[out] out Output object. Should be a ResponseEnvelope or a type inherited from ResponseEnvelope.
		/// @return true iff the input JSON parsed correctly, false otherwise
		template<typename T>
		bool ParseResponse(const char * bytes, uint32_t length, T& out)
		{
			nlohmann::json value = nlohmann::json::parse(bytes, bytes + length, nullptr, false);
			if (value.is_discarded())
			{
				return false;
			}

			from_json(value, out);
			return true;
		}

		/// Parses a ReceiveEnvelope only. Does not attempt to parse the body.
		/// @param[in] bytes JSON input bytes. Must not be null.
		/// @param[in] length Length of the bytes parameter
		/// @param[out] success Optional boolean to determine parse failure. Will be set to true iff the parse succeeded, false otherwise.
		/// @return A ReceiveEnvelope with no body, only metadata field and possibly errors.
		ReceiveEnvelope<EmptyBody> ParseEnvelope(const char * bytes, uint32_t length, bool* success = nullptr);
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_SUBSCRIPTION_H
#define MUXY_GAMELINK_SCHEMA_SUBSCRIPTION_H

namespace gamelink
{
	namespace schema
	{
		struct SubscribeTopicRequestBody
		{
			string topic_id;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(SubscribeTopicRequestBody, "topic_id", topic_id);
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_AUTHENTICATION_H
#define MUXY_GAMELINK_SCHEMA_AUTHENTICATION_H


namespace gamelink
{
	namespace schema
	{
		struct AuthenticateWithPINRequestBody
		{
			/// PIN string, as obtained from the REST API
			string pin;

			/// Client ID, as obtained from Twitch.
			string client_id;
		};
		MUXY_GAMELINK_SERIALIZE_2(AuthenticateWithPINRequestBody, "pin", pin, "client_id", client_id);

		struct AuthenticateWithJWTRequestBody
		{
			/// JWT string, as obtained from previous authorizations
			string jwt;

			/// Client ID, as obtained from Twitch.
			string client_id;
		};
		MUXY_GAMELINK_SERIALIZE_2(AuthenticateWithJWTRequestBody, "jwt", jwt, "client_id", client_id);

		struct AuthenticateJWTResponseBody
		{
			/// Signed JWT. Will expire.
			string jwt;
		};
		MUXY_GAMELINK_SERIALIZE_1(AuthenticateJWTResponseBody, "jwt", jwt);

		struct SubscribeAuthenticationRequest : SendEnvelope<EmptyBody>
		{
			SubscribeAuthenticationRequest();
		};

		struct SubscribeAuthenticationResponse : ReceiveEnvelope<OKResponseBody>
		{};

		struct AuthenticateWithPINRequest : SendEnvelope<AuthenticateWithPINRequestBody>
		{
			/// Creates an authorization request.
			/// @param[in] clientID Client ID.
			/// @param[in] pin PIN obtained from user input.
			AuthenticateWithPINRequest(const string& clientID, const string& pin);
		};

		struct AuthenticateWithJWTRequest : SendEnvelope<AuthenticateWithJWTRequestBody>
		{
			/// Creates an authorization request
			/// @param[in] clientID Client ID.
			/// @param[in] jwt JWT obtained from previous authorizations.
			AuthenticateWithJWTRequest(const string& clientID, const string& jwt);
		};

		struct AuthenticateResponse : ReceiveEnvelope<AuthenticateJWTResponseBody>
		{};

		class User
		{
		public:
			explicit User(string jwt);

			const string& GetJWT() const;
			// string GetOpaqueID();
		private:
			string jwt;
		};
	}
}
#endif


#ifndef MUXY_GAMELINK_SCHEMA_POLL_H
#define MUXY_GAMELINK_SCHEMA_POLL_H



namespace gamelink
{
	namespace schema
	{
		struct GetPollRequestBody
		{
			/// The Poll ID to get
			string pollId;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(GetPollRequestBody, "poll_id", pollId);
		};

		struct DeletePollRequestBody
		{
			string pollId;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(DeletePollRequestBody, "poll_id", pollId);
		};

		struct CreatePollRequestBody
		{
			/// The Poll ID to create. Poll IDs are scoped to the current channel.
			string pollId;

			/// The poll prompt
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(CreatePollRequestBody, "poll_id", pollId, "prompt", prompt, "options", options);
		};

		template<typename T>
		struct CreatePollWithUserDataRequestBody
		{
			/// The Poll ID to create
			string pollId;

			/// The prompt for the poll.
			string prompt;

			/// An array of options for the poll
			std::vector<string> options;

			/// Arbitrary serializable user data.
			T userData;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_4(CreatePollWithUserDataRequestBody,
												"poll_id",
												pollId,
												"prompt",
												prompt,
												"options",
												options,
												"user_data",
												userData);
		};

		struct PollResponseBody
		{
			/// The prompt for the poll.
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(PollResponseBody, "prompt", prompt, "options", options);
		};

		template<typename T>
		struct PollWithUserDataResponseBody
		{
			/// The prompt for the poll.
			string prompt;

			/// A list of answers to the prompt. Maximum 64.
			std::vector<string> options;

			/// Arbitrary user data type. Must be marked up with the MUXY_GAMELINK_SERIALIZE macro.
			T userData;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollWithUserDataResponseBody, "prompt", prompt, "options", options, "user_data", userData);
		};

		struct PollUpdateBody
		{
			/// The Poll ID that the update is for
			string pollId;

			/// The poll information
			PollResponseBody poll;

			/// Array of vote counts for each poll option. This array may not be the same size as the
			/// options array.
			std::vector<int> results;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollUpdateBody, "topic_id", pollId, "poll", poll, "results", results);
		};

		template<typename T>
		struct PollWithUserDataUpdateBody
		{
			/// The Poll ID that this update represents
			string pollId;

			/// The poll prompt and options.
			PollWithUserDataResponseBody<T> poll;

			/// An array of vote counts for each poll option. This array may not be the same
			/// size as the options array.
			std::vector<int> results;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(PollWithUserDataUpdateBody, "topic_id", pollId, "poll", poll, "results", results);
		};

		struct GetPollRequest : SendEnvelope<GetPollRequestBody>
		{
			/// Creates a GetPoll request
			/// @param[in] pollId The ID of the poll to get. Maximum size 64 characters.
			explicit GetPollRequest(const string& pollId);
		};

		struct CreatePollRequest : SendEnvelope<CreatePollRequestBody>
		{
			/// Creates a CreatePoll request.
			/// @param[in] pollId The ID of the poll to create. This can overwrite existing polls if the same
			///                   id is specified.
			/// @param[in] prompt The prompt for the poll to create.
			/// @param[in] options vector of options for the poll.
			CreatePollRequest(const string& pollId, const string& prompt, const std::vector<string>& options);
		};

		template<typename T>
		struct CreatePollWithUserDataRequest : SendEnvelope<CreatePollWithUserDataRequestBody<T>>
		{
			/// Creates a CreatePoll request, but with user data.
			/// @param[in] pollId The ID of the poll to create. This can overwrite existing polls if the same
			///                   id is specified.
			/// @param[in] prompt The prompt for the poll to create.
			/// @param[in] options vector of options for the poll.
			/// @param[in] userData Arbitrary user data to attach to this poll. This type should be serializable. The fully marshalled
			///                     size of this type should be under 1kb.
			CreatePollWithUserDataRequest(const string& pollId, const string& prompt, const std::vector<string>& options, const T& userData)
			{
				this->action = string("create");
				this->params.target = string("poll");

				this->data.pollId = pollId;
				this->data.prompt = prompt;
				this->data.options = options;

				this->data.userData = userData;
			}
		};

		struct SubscribePollRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribePollRequest.
			/// @param[in] pollId The ID of the poll to subscribe to updates for.
			SubscribePollRequest(const string& pollId);
		};

		struct PollUpdateResponse : ReceiveEnvelope<PollUpdateBody>
		{
			PollUpdateResponse(){};
			PollUpdateResponse(const string& pollId,
							   const string& prompt,
							   const std::vector<string>& options,
							   const std::vector<int>& results);
		};

		template<typename T>
		struct PollWithUserDataUpdateResponse : ReceiveEnvelope<PollWithUserDataUpdateBody<T>>
		{
		};

		struct DeletePollRequest : SendEnvelope<DeletePollRequestBody>
		{
			/// Creates a DeletePoll request
			/// @param[in] pollId 	The ID of the poll to be deleted.
			DeletePollRequest(const string& pollId);
		};
	}
}

#endif


#ifndef MUXY_GAMELINK_SCHEMA_H
#define MUXY_GAMELINK_SCHEMA_H







#endif

#ifndef MUXY_GAMELINK_SCHEMA_STATE_H
#define MUXY_GAMELINK_SCHEMA_STATE_H



namespace gamelink
{
	namespace schema
	{
		// Set / Get state
		template<typename T>
		struct SetStateRequestBody
		{
			/// The state to set. The type `T` should be serializable
			/// through use of the MUXY_GAMELINK_SERIALIZE macros.
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(SetStateRequestBody, "state", state);
		};

		template<typename T>
		struct StateResponseBody
		{
			/// Will always be true.
			bool ok;

			/// State response. The type `T` should be serializable
			/// through use of the MUXY_GAMELINK_SERIALIZE macros.
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(StateResponseBody, "ok", ok, "state", state);
		};

		/// Channel State target
		static const char* STATE_TARGET_CHANNEL = "channel";

		/// Extension State target
		static const char* STATE_TARGET_EXTENSION = "extension";

		template<typename T>
		struct SetStateRequest : SendEnvelope<SetStateRequestBody<T>>
		{
			/// Creates a SetState request.
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			/// @param[in] value A serializable type.
			SetStateRequest(const char* target, const T& value)
			{
				this->action = string("set");
				this->params.target = string(target);
				this->data.state = value;
			}
		};

		template<typename T>
		struct SetStateResponse : ReceiveEnvelope<StateResponseBody<T>>
		{
		};

		struct GetStateRequest : SendEnvelope<EmptyBody>
		{
			/// Creates a GetState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit GetStateRequest(const char* target);
		};

		template<typename T>
		struct GetStateResponse : ReceiveEnvelope<StateResponseBody<T>>
		{
		};

		// Update state
		struct UpdateOperation
		{
			string operation;
			string path;
			JsonAtom value;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_3(UpdateOperation, "op", operation, "path", path, "value", value);
		};

		struct UpdateStateRequestBody
		{
			std::vector<UpdateOperation> state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_1(UpdateStateRequestBody, "state", state);
		};

		struct UpdateStateRequest : SendEnvelope<UpdateStateRequestBody>
		{
			/// Creates an UpdateState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit UpdateStateRequest(const char* target);
		};

		// Subscription
		template<typename T>
		struct StateUpdateBody
		{
			string topic_id;
			T state;

			MUXY_GAMELINK_SERIALIZE_INTRUSIVE_2(StateUpdateBody, "topic_id", topic_id, "state", state);
		};

		struct SubscribeStateRequest : SendEnvelope<SubscribeTopicRequestBody>
		{
			/// Creates a SubscribeState request
			/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
			explicit SubscribeStateRequest(const char* target);
		};

		template<typename T>
		struct SubscribeStateUpdateResponse : ReceiveEnvelope<StateUpdateBody<T>>
		{
		};
	}
}
#endif


#ifndef INCLUDE_MUXY_GAMELINK_H
#define INCLUDE_MUXY_GAMELINK_H


#include <queue>

namespace gamelink
{
	class Send
	{
	public:
		Send(string data);

		string data;
	};

	namespace detail
	{
		template<typename T>
		class Callback
		{
		public:
			typedef void (*RawFunctionPointer)(void*, const T&);

			Callback()
				: _rawCallback(nullptr)
				, _user(nullptr)
			{
			}

			void invoke(const T& v)
			{
				if (_rawCallback)
				{
					_rawCallback(_user, v);
				}
				else if (_callback)
				{
					_callback(v);
				}
			}

			void set(std::function<void(const T&)> fn)
			{
				_rawCallback = nullptr;
				_user = nullptr;

				_callback = fn;
			}

			void set(RawFunctionPointer cb, void* user)
			{
				_rawCallback = cb;
				_user = user;

				_callback = std::function<void(const T&)>();
			}

			bool valid() const
			{
				if (_rawCallback) 
				{
					return true;
				}

				if (_callback)
				{
					return true;
				}

				return false;
			}
		private:
			RawFunctionPointer _rawCallback;
			void* _user;

			std::function<void(const T&)> _callback;
		};
	}

	
	class SDK
	{
	public:
		SDK();
		~SDK();

		bool ReceiveMessage(const char* bytes, uint32_t length);

		bool HasSends()
		{
			return _sendQueue.size() > 0;
		}

		template<typename T>
		void ForeachSend(const T& networkCallback)
		{
			while (HasSends())
			{
				Send* send = _sendQueue.front();
				_sendQueue.pop();

				networkCallback(send);

				// Clean up send
				delete send;
			}
		}

		typedef void (*SendCallback)(const Send*);
		void ForeachSend(SendCallback cb, void* user);

		bool IsAuthenticated() const;

		const schema::User* GetUser() const;

		/// Sets the OnDebugMessage callback. These messages are emitted
		/// for debugging purposes only.
		void OnDebugMessage(std::function<void(const string&)> callback);
		void OnDebugMessage(void (*callback)(void*, const string&), void *ptr);
		
		// Callbacks
		void OnPollUpdate(std::function<void(const schema::PollUpdateResponse&)> callback);
		void OnPollUpdate(void (*callback)(void*, const schema::PollUpdateResponse&), void* ptr);

		void OnAuthenticate(std::function<void(const schema::AuthenticateResponse&)> callback);
		void OnAuthenticate(void (*callback)(void*, const schema::AuthenticateResponse&), void* ptr);

		void OnStateUpdate(std::function<void(const schema::SubscribeStateUpdateResponse<nlohmann::json>&)> callback);
		void OnStateUpdate(void (*callback)(void*, const schema::SubscribeStateUpdateResponse<nlohmann::json>&), void* ptr);

		/// Queues an authentication request using a PIN code, as received by the user from an extension's config view.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] pin 		The PIN input from the broadcaster
		void AuthenticateWithPIN(const string& clientId, const string& pin);

		/// Queues an authentication request using a JWT, as received after a successful PIN authentication request.
		///
		/// @param[in] clientId The extension's client ID
		/// @param[in] jwt 		The stored JWT from a previous authentication
		void AuthenticateWithJWT(const string& clientId, const string& jwt);

		// Poll stuff, all async.

		/// Queues a request to get poll information, including results, for the poll with the given ID.
		/// Roughly equivilent to a single poll subscription update.
		/// Results are obtained through the OnPollUpdate callback.
		///
		/// @param[in] pollId The Poll ID to get information for
		void GetPoll(const string& pollId);

		/// Queues a request to create a poll.
		///
		/// @param[in] pollId The Poll ID to create
		/// @param[in] prompt The Prompt to store in the poll.
		/// @param[in] options An array of options to store in the poll.
		void CreatePoll(const string& pollId, const string& prompt, const std::vector<string>& options);

		/// Queues a request to create a poll.
		///
		/// @param[in] pollId The Poll ID to create
		/// @param[in] prompt The Prompt to store in the poll.
		/// @param[in] optionsBegin Pointer to the first element in an array of options to store in the poll.
		/// @param[in] optionsEnd Pointer one past the final entry in an array of options to store in the poll.
		void CreatePoll(const string& pollId, const string& prompt, const string* optionsBegin, const string* optionsEnd);

		/// Subscribes to updates for a given poll.
		/// Updates come through the OnPollUpdate callback.
		/// Once a poll stops receiving new votes, the subscription will stop receiving new updates.
		///
		/// @param[in] pollId The Poll ID to create
		void SubscribeToPoll(const string& pollId);

		/// Deletes the poll with the given ID.
		///
		/// @param[in] pollId 	The ID of the poll to delete.
		void DeletePoll(const string& pollId);

		// State operations, all async.

		/// Queues a request to replace the entirety of state with new information.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] value A serializable type. Will overwrite any existing state for the given target.
		///                  Cannot be an array or primitive type.
		template<typename T>
		void SetState(const char* target, const T& value)
		{
			nlohmann::json js = nlohmann::json(value);
			SetState(target, js);
		};

		/// Queues a request to replace the entirety of state with new information.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] value JSON. Will overwrite any existing state for the given target.
		///                  Must be an object, not an array or primitive type.
		void SetState(const char* target, const nlohmann::json& value);

		/// Queues a request to get state.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		void GetState(const char* target);

		/// Queues a request to do a single JSON Patch operation on the state object.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] operation A JSON Patch operation
		/// @param[in] path A JSON Patch path.
		/// @param[in] atom The value to use in the patch operation
		void UpdateState(const char* target, const string& operation, const string& path, const schema::JsonAtom& atom);

		/// Queues a request to do many JSON Patch operations on the state object.
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		/// @param[in] begin Pointer to the first element in an array of UpdateOperations
		/// @param[in] end Pointer one past the last element in an array of UpdateOperations
		void UpdateState(const char* target, const schema::UpdateOperation* begin, const schema::UpdateOperation* end);

		/// Starts subscribing to state updates for the given target.
		/// Updates come through the OnStateUpdate callback
		///
		/// @param[in] target Either STATE_TARGET_CHANNEL or STATE_TARGET_EXTENSION
		void SubscribeToStateUpdates(const char* target);
	private:
		void debugLogSend(const Send *);

		template<typename Payload>
		void queuePayload(const Payload& p)
		{
			Send* send = new Send(to_string(p));
			debugLogSend(send);
			_sendQueue.push(send);
		}

		std::queue<Send*> _sendQueue;
		schema::User* _user;

		detail::Callback<string> _onDebugMessage;

		detail::Callback<schema::PollUpdateResponse> _onPollUpdate;
		detail::Callback<schema::AuthenticateResponse> _onAuthenticate;
		detail::Callback<schema::SubscribeStateUpdateResponse<nlohmann::json>> _onStateUpdate;
	};
}

#endif

#ifdef MUXY_GAMELINK_SINGLE_IMPL


namespace gamelink
{
	namespace schema
	{
		SubscribeAuthenticationRequest::SubscribeAuthenticationRequest()
		{
			action = string("subscribe");
			params.target = string("authentication");
		}

		AuthenticateWithPINRequest::AuthenticateWithPINRequest(const string& client, const string& pin)
		{
			action = string("authenticate");
			params.target = string("");
			data.pin = pin;
			data.client_id = client;
		}

		AuthenticateWithJWTRequest::AuthenticateWithJWTRequest(const string& client, const string& jwt)
		{
			action = string("authenticate");
			params.target = string("");
			data.jwt = jwt;
			data.client_id = client;
		}

		User::User(string jwt) : jwt(std::move(jwt))
		{
		}

		const string& User::GetJWT() const
		{
			return this->jwt;
		}
	}
}



namespace gamelink
{
	namespace schema
	{
		JsonAtom atomFromInteger(int64_t v)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_INT64;
			atom.int64Value = v;

			return atom;
		}

		JsonAtom atomFromDouble(double v)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_DOUBLE;
			atom.doubleValue = v;

			return atom;
		}

		JsonAtom atomFromString(const string& str)
		{
			JsonAtom atom;

			atom.type = JSON_ATOM_STRING;
			atom.stringValue = str;

			return atom;
		}

		JsonAtom atomNull(int64_t v)
		{
			JsonAtom atom;
			atom.type = JSON_ATOM_NULL;
			return atom;
		}

		void to_json(nlohmann::json& out, const JsonAtom& p)
		{
			switch (p.type)
			{
			case JSON_ATOM_NULL:
				out = nlohmann::json();
				break;
			case JSON_ATOM_INT64:
				out = p.int64Value;
				break;
			case JSON_ATOM_DOUBLE:
				out = p.doubleValue;
				break;
			case JSON_ATOM_STRING:
				out = p.stringValue;
				break;
			default:
				// Bad
				out = nlohmann::json();
				break;
			}
		}

		void from_json(const nlohmann::json& n, JsonAtom& p)
		{
			p.type = JSON_ATOM_NULL;
			if (n.is_null())
			{
				p.type = JSON_ATOM_NULL;
				return;
			}
			else if (n.is_string())
			{
				p.stringValue = n.get<string>();
				return;
			}
			else if (n.is_number_integer())
			{
				p.int64Value = n.get<int64_t>();
				return;
			}
			else if (n.is_number())
			{
				p.doubleValue = n.get<double>();
			}
		}

		ReceiveMeta::ReceiveMeta()
			: request_id(0)
			, timestamp(0)
		{
		}

		SendParameters::SendParameters()
			: request_id(0xFFFF)
		{
		}

		ReceiveEnvelope<EmptyBody> ParseEnvelope(const char * bytes, uint32_t length, bool * outSuccess)
		{
			ReceiveEnvelope<EmptyBody> out;
			bool result = ParseResponse(bytes, length, out);
			if (outSuccess) 
			{
				*outSuccess = result;
			}
			return out;
		}
	}
}



namespace gamelink
{
	namespace schema
	{
		GetPollRequest::GetPollRequest(const string& pollId)
		{
			action = string("get");
			params.target = string("poll");

			data.pollId = pollId;
		}

		DeletePollRequest::DeletePollRequest(const string& pollId)
		{
			action = string("delete");
			params.target = string("poll");

			data.pollId = pollId;
		}

		CreatePollRequest::CreatePollRequest(const string& pollId, const string& prompt, const std::vector<string>& options)
		{
			action = string("create");
			params.target = string("poll");

			data.pollId = pollId;
			data.prompt = prompt;
			data.options = options;
		}

		SubscribePollRequest::SubscribePollRequest(const string& pollId)
		{
			action = string("subscribe");
			params.target = string("poll");
			data.topic_id = string(pollId);
		}

		PollUpdateResponse::PollUpdateResponse(const string& pollId,
											   const string& prompt,
											   const std::vector<string>& options,
											   const std::vector<int>& results)
		{
			meta.action = string("update");
			meta.target = string("poll");

			data.pollId = string(pollId);
			data.poll.prompt = string(prompt);
			data.poll.options = options;
			data.results = results;
		}
	}
}



namespace gamelink
{
    namespace schema
    {
        GetStateRequest::GetStateRequest(const char * target)
        {
            action = string("get");
            params.target = string(target);
        }
        
        UpdateStateRequest::UpdateStateRequest(const char * target)
        {
            action = string("update");
            params.target = string(target);
        }

        SubscribeStateRequest::SubscribeStateRequest(const char * target)
        {
            action = string("subscribe");
            params.target = string("state");
            data.topic_id = string(target);    
        }
    }
}
#ifndef INCLUDE_MUXY_GAMELINK_CPP
#define INCLUDE_MUXY_GAMELINK_CPP


#include <cstdio>

namespace gamelink
{
	Send::Send(string data)
	{
		this->data = data;
	}

	SDK::SDK()
		: _user(NULL){};

	SDK::~SDK()
	{
		// Clean up unsent messages
		while (HasSends())
		{
			Send* send = _sendQueue.front();
			_sendQueue.pop();
			delete send;
		}
	}
	
	void SDK::debugLogSend(const Send * s)
	{
		if (_onDebugMessage.valid())
		{
			uint32_t bufferLength = s->data.size() + 128;
			char * buffer = new char[bufferLength];

			int offset = snprintf(buffer, bufferLength, "send len=%d msg=", static_cast<int>(s->data.size()));
			memcpy(buffer + offset, s->data.c_str(), s->data.size());
			buffer[s->data.size() + offset] = '\0';

			_onDebugMessage.invoke(string(buffer));

			delete [] buffer;
		}
	}

	bool SDK::ReceiveMessage(const char* bytes, uint32_t length)
	{
		bool success = false;
		auto env = schema::ParseEnvelope(bytes, length);

		if (_onDebugMessage.valid())
		{
			uint32_t bufferLength = length + 128;
			char * buffer = new char[bufferLength];

			int offset = snprintf(buffer, bufferLength, "recv len=%d msg=", static_cast<int>(length));
			memcpy(buffer + offset, bytes, length);
			buffer[length + offset] = '\0';

			_onDebugMessage.invoke(string(buffer));

			delete [] buffer;
		}

		if (env.meta.action == "authenticate")
		{
			// Authentication response
			schema::AuthenticateResponse authResp;
			success = schema::ParseResponse<schema::AuthenticateResponse>(bytes, length, authResp);
			if (success)
			{
				_onAuthenticate.invoke(authResp);
				this->_user = new schema::User(authResp.data.jwt);
			}
		}
		else if (env.meta.action == "update")
		{
			if (env.meta.target == "poll")
			{
				// Poll update response
				// TODO Handle a UserDataPollUpdateResponse as well
				schema::PollUpdateResponse pollResp;
				success = schema::ParseResponse<schema::PollUpdateResponse>(bytes, length, pollResp);
				if (success)
				{
					_onPollUpdate.invoke(pollResp);
				}
			}

			if (env.meta.target == "channel")
			{
				schema::SubscribeStateUpdateResponse<nlohmann::json> resp;

				success = schema::ParseResponse(bytes, length, resp);
				if (success)
				{
					_onStateUpdate.invoke(resp);
				}
			}
		}

		return success;
	}

	bool SDK::IsAuthenticated() const
	{
		return _user != NULL;
	}

	const schema::User* SDK::GetUser() const
	{
		return _user;
	}

	// Callbacks
	void SDK::OnDebugMessage(std::function<void(const string&)> callback)
	{
		_onDebugMessage.set(callback);
	}

	void SDK::OnDebugMessage(void (*callback)(void*, const string&), void *ptr)
	{
		_onDebugMessage.set(callback, ptr);
	}

	void SDK::OnPollUpdate(std::function<void(const schema::PollUpdateResponse& pollResponse)> callback)
	{
		_onPollUpdate.set(callback);
	}

	void SDK::OnPollUpdate(void (*callback)(void*, const schema::PollUpdateResponse&), void* ptr)
	{
		_onPollUpdate.set(callback, ptr);
	}

	void SDK::OnAuthenticate(std::function<void(const schema::AuthenticateResponse&)> callback)
	{
		_onAuthenticate.set(callback);
	}

	void SDK::OnAuthenticate(void (*callback)(void*, const schema::AuthenticateResponse&), void* ptr)
	{
		_onAuthenticate.set(callback, ptr);
	}

	void SDK::OnStateUpdate(std::function<void(const schema::SubscribeStateUpdateResponse<nlohmann::json>&)> callback)
	{
		_onStateUpdate.set(callback);
	}

	void SDK::OnStateUpdate(void (*callback)(void*, const schema::SubscribeStateUpdateResponse<nlohmann::json>&), void* ptr)
	{
		_onStateUpdate.set(callback, ptr);
	}

	void SDK::AuthenticateWithPIN(const string& clientId, const string& pin)
	{
		schema::AuthenticateWithPINRequest payload(clientId, pin);
		queuePayload(payload);
	}

	void SDK::AuthenticateWithJWT(const string& clientId, const string& jwt)
	{
		schema::AuthenticateWithJWTRequest payload(clientId, jwt);
		queuePayload(payload);
	}

	void SDK::GetPoll(const string& pollId)
	{
		schema::GetPollRequest packet(pollId);
		queuePayload(packet);
	}

	void SDK::CreatePoll(const string& pollId, const string& prompt, const std::vector<string>& options)
	{
		schema::CreatePollRequest packet(pollId, prompt, options);
		queuePayload(packet);
	}

	void SDK::SubscribeToPoll(const string& pollId)
	{
		schema::SubscribePollRequest packet(pollId);
		queuePayload(packet);
	}

	void SDK::DeletePoll(const string& pollId)
	{
		schema::DeletePollRequest payload(pollId);
		queuePayload(payload);
	}

	void SDK::SetState(const char* target, const nlohmann::json& value)
	{
		schema::SetStateRequest<nlohmann::json> payload(target, value);
		queuePayload(payload);
	}

	void SDK::GetState(const char* target)
	{
		schema::GetStateRequest payload(target);
		queuePayload(payload);
	}

	void SDK::SubscribeToStateUpdates(const char* target)
	{
		schema::SubscribeStateRequest payload(target);
		queuePayload(payload);
	}

	void SDK::UpdateState(const char* target, const string& operation, const string& path, const schema::JsonAtom& atom)
	{
		schema::UpdateOperation op;
		op.operation = operation;
		op.path = path;
		op.value = atom;

		UpdateState(target, &op, &op + 1);
	}

	void SDK::UpdateState(const char* target, const schema::UpdateOperation* begin, const schema::UpdateOperation* end)
	{
		schema::UpdateStateRequest payload(target);
		std::vector<schema::UpdateOperation> updates;
		updates.resize(end - begin);
		std::copy(begin, end, updates.begin());

		payload.data.state = std::move(updates);
		queuePayload(payload);
	};
}

#endif

#endif
#endif
